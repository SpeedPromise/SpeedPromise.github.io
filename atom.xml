<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hyacinthの博客</title>
  
  <subtitle>记录点滴日常</subtitle>
  <link href="https://hyacinth.fit/atom.xml" rel="self"/>
  
  <link href="https://hyacinth.fit/"/>
  <updated>2021-08-08T04:40:56.044Z</updated>
  <id>https://hyacinth.fit/</id>
  
  <author>
    <name>Hyacinth</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>跳表</title>
    <link href="https://hyacinth.fit/archives/2e152a56.html"/>
    <id>https://hyacinth.fit/archives/2e152a56.html</id>
    <published>2021-08-08T03:19:14.000Z</published>
    <updated>2021-08-08T04:40:56.044Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/08/xe4MyIJXcmufOQa.jpg" style="zoom:50%;" /><p>跳表是一种各方面性能都比较优秀的<strong>动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）</p><span id="more"></span><p>对于存储在链表中的数据，只需要对链表稍加改造，就可以支持类似“二分”的查找算法，我们把改造后的数据结构叫做<strong>跳表</strong>（Skip list）</p><h3 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h3><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p><img data-src="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg" style="zoom:50%;" /><p>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做<strong>索引</strong>或<strong>索引层</strong>。</p><img data-src="https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg" style="zoom:50%;" /><p>假如现在要查找结点16，我们可以先在索引层遍历，当遍历到索引值为13时，发现下一结点是17，那要查找的结点16就在这两结点之间。然后我们通过索引层结点的down指针，下降到原始链表层，继续遍历即可。原来需要遍历10个结点，现在只需要7个结点。</p><p>从这个例子里，我们看出，<strong>加来一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</strong>。</p><p>数据量大的话，可以添加多层索引提升效率。<strong>这种链表加多级索引的结构，就是跳表</strong>。</p><img data-src="https://i.loli.net/2021/08/08/tKFQ2YcO1dnWS9E.jpg" style="zoom:50%;" /><h3 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h3><p>每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，**第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 $n/(2k)$**。</p><p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 n/(2h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p><p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点，即 m=3。</p><img data-src="https://i.loli.net/2021/08/08/2tfn93XdPqk5oKi.jpg" style="zoom:50%;" /><h3 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h3><p>跳表就是通过空间换时间的设计思路来实现了和二分查找一样的时间复杂度。根据前面的公式，可以得到跳表的空间复杂度就是$n/2+n/4+n/8…+8+4+2=n-2$​。</p><p>如果想要降低索引占用的内存空间，也可以选择三个结点或五个结点抽取一个到上级索引。</p><p>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了</p><h3 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h3><p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。因为插入、删除操作的耗时都在查找遍历上，要注意删除时如果结点在索引中也有出现，那要同事删除原始链表和索引的结点</p><h3 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h3><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p><img data-src="https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg" style="zoom:50%;" /><p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p><p>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p><p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p><img data-src="https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/08/xe4MyIJXcmufOQa.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;跳表是一种各方面性能都比较优秀的&lt;strong&gt;动态数据结构&lt;/strong&gt;，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树（Red-black tree）&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://hyacinth.fit/archives/e8eb0481.html"/>
    <id>https://hyacinth.fit/archives/e8eb0481.html</id>
    <published>2021-08-07T02:59:52.000Z</published>
    <updated>2021-08-08T04:42:16.047Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://static001.geekbang.org/resource/image/ca/df/ca9c8119a7532fc8a7b249af019bf3df.jpg" style="zoom:50%;" /><p>假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？</p><span id="more"></span><h3 id="无处不在的二分思想"><a href="#无处不在的二分思想" class="headerlink" title="无处不在的二分思想"></a>无处不在的二分思想</h3><p>随机写一个 0 到 99 之间的数字，然后你来猜我写的是什么。猜的过程中，你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。</p><p>假设数字是 23，你可以按照下面的步骤来试一试。</p><img data-src="https://i.loli.net/2021/08/07/u6aGvywhBXeCHbm.jpg" style="zoom:50%;" /><p>这个例子用的就是二分思想，按照这个思想，即便我让你猜的是 0 到 999 的数字，最多也只要 10 次就能猜中。</p><p>这是一个生活中的例子，我们现在回到实际的开发场景中。假设有 1000 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。我们现在想知道是否存在金额等于 19 元的订单。如果存在，则返回订单数据，如果不存在则返回 null。</p><p>最简单的办法当然是从第一个订单开始，一个一个遍历这 1000 个订单，直到找到金额等于 19 元的订单为止。但这样查找会比较慢，最坏情况下，可能要遍历完这 1000 条记录才能找到。那用二分查找能不能更快速地解决呢？</p><p>为了方便讲解，我们假设只有 10 个订单，订单金额分别是：8，11，19，23，27，33，45，55，67，98。</p><p>还是利用二分思想，每次都与区间的中间数据比对大小，缩小查找区间的范围。为了更加直观，我画了一张查找过程的图。其中，low 和 high 表示待查找区间的下标，mid 表示待查找区间的中间元素下标。</p><img data-src="https://static001.geekbang.org/resource/image/8b/29/8bce81259abf0e9a06f115e22586b829.jpg" style="zoom:50%;" /><p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</strong></p><h3 id="O-logn-​​惊人的查找"><a href="#O-logn-​​惊人的查找" class="headerlink" title="$O(logn)$​​惊人的查找"></a>$O(logn)$​​惊人的查找</h3><p>二分查找十分高效。我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p><img data-src="https://i.loli.net/2021/08/07/cDUVBderYRxmXht.jpg" style="zoom:50%;" /><p>可以求得 k=log2n，所以时间复杂度就是 O(logn)。O(logn) 这种对数时间复杂度。这是一种极其高效的时间复杂度，有的时候甚至比时间复杂度是常量级 O(1) 的算法还要高效。</p><p>因为 logn 是一个非常“恐怖”的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。</p><p>用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高。</p><h3 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h3><p>最简单的情况就是有序数组中不存在重复元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要着重强调一下容易出错的 3 个地方。</p><ol><li><p><strong>循环退出条件</strong></p><p>注意是 low&lt;=high，而不是 low&gt;1</p></li><li><p><strong>mid 的取值</strong></p><p>实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为相比除法运算来说，计算机处理位运算要快得多。</p></li><li><p><strong>low 和 high 的更新</strong></p><p>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出。</p></li></ol><p><strong>二分查找的递归实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h3><p><strong>二分查找依赖的是顺序表结构，简单点说就是数组</strong></p><p>二分查找需要按照下标随机访问元素，如果使用链表这种数据结构，时间复杂会变得很高。</p><p><strong>二分查找针对的是有序数据</strong></p><p>如果数据没有序，我们需要先排序。前面章节里我们讲到，排序的时间复杂度最低是 O(nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p><p>但是，如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p><p>所以，二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中。针对动态变化的数据集合，二分查找将不再适用。</p><p><strong>数据量太小不适合二分查找。</strong></p><p>比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p><p>不过，这里有一个例外。如果数据之间的比较操作非常耗时，不管数据量大小，我都推荐使用二分查找。比如，数组中存储的都是长度超过 300 的字符串，如此长的两个字符串之间比对大小，就会非常耗时。我们需要尽可能地减少比较次数，而比较次数的减少会大大提高性能，这个时候二分查找就比顺序遍历更有优势。</p><p><strong>数据量太大也不适合二分查找。</strong></p><p>二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。</p><p>注意这里的“连续”二字，也就是说，即便有 2GB 的内存空间剩余，但是如果这剩余的 2GB 内存空间都是零散的，没有连续的 1GB 大小的内存空间，那照样无法申请一个 1GB 大小的数组。而我们的二分查找是作用在数组这种数据结构之上的，所以太大的数据用数组存储就比较吃力了，也就不能用二分查找了。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://static001.geekbang.org/resource/image/ca/df/ca9c8119a7532fc8a7b249af019bf3df.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;假设我们有 1000 万个整数数据，每个数据占 8 个字节，如何设计数据结构和算法，快速判断某个整数是否出现在这 1000 万数据中？ 我们希望这个功能不要占用太多的内存空间，最多不要超过 100MB，你会怎么做呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序优化</title>
    <link href="https://hyacinth.fit/archives/7418344d.html"/>
    <id>https://hyacinth.fit/archives/7418344d.html</id>
    <published>2021-08-04T04:36:23.000Z</published>
    <updated>2021-08-05T05:06:32.939Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/05/5DAt1oVdSKu4Bqr.jpg" style="zoom:50%;" /><p>如何实现一个通用的、高性能的排序函数？</p><span id="more"></span><h3 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h3><p>先回顾下前面讲过的几种算法</p><img data-src="https://static001.geekbang.org/resource/image/1f/fd/1f6ef7e0a5365d6e9d68f0ccc71755fd.jpg" style="zoom:50%;" /><p>线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，不能选择线性排序算法。</p><p>如果对小规模数据进行排序，可以选择时间复杂度是 O(n2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数。</p><p>堆排序和快速排序都有比较多的应用，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。一般不适用归并排序的原因是它不是原地排序算法，空间复杂度是$O(n)$。​</p><h3 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h3><p>快排在最坏情况下时间复杂度是$O(n^2)$​，主要原因还是因为我们分区点选得不够合理。最理想的分区点是：被分区点分开的两个分区中，数据的数量差不多。下面介绍两个常用简单的分区算法。</p><ol><li><strong>三数取中法</strong></li></ol><p>区间的首、尾、中间，分别取出一个数，然后对比大小，取这 3 个数的中间值作为分区点。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”</p><ol start="2"><li><strong>随机法</strong></li></ol><p>每次从要排序的区间中，随机选择一个元素作为分区点。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。时间复杂度退化为最糟糕的 O(n2) 的情况，出现的可能性不大。</p><p>递归要警惕堆栈溢出。为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：第一种是限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归。第二种是通过在堆上模拟实现一个函数调用栈，手动模拟递归压栈、出栈的过程，这样就没有了系统栈大小的限制。</p><h3 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h3><p>这里拿 Glibc 中的 qsort() 函数举例说明一下</p><p>qsort() 会优先使用归并排序来排序输入数据，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。</p><p>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序。那 qsort() 是如何选择快速排序算法的分区点的呢？如果去看源码，你就会发现，qsort() 选择分区点的方法就是“三数取中法”。</p><p>还有我们前面提到的递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的.</p><p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，在小规模数据面前，O(n2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长。</p><p>时间复杂度代表的是一个增长趋势，如果画成增长曲线图，你会发现 O(n2) 比 O(nlogn) 要陡峭，也就是说增长趋势要更猛一些。但是，我们前面讲过，在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。</p><p>在 qsort() 插入排序的算法实现中，也利用了哨兵这种编程技巧。虽然哨兵可能只是少做一次判断，但是毕竟排序函数是非常常用、非常基础的函数，性能的优化要做到极致。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/05/5DAt1oVdSKu4Bqr.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;如何实现一个通用的、高性能的排序函数？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>线性排序</title>
    <link href="https://hyacinth.fit/archives/89c5f6b.html"/>
    <id>https://hyacinth.fit/archives/89c5f6b.html</id>
    <published>2021-08-04T04:35:39.000Z</published>
    <updated>2021-08-05T05:06:10.648Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://static001.geekbang.org/resource/image/53/3a/538f4aefb62df6171579293a87d9ca3a.jpg" style="zoom:50%;" /><p>如何根据年龄给 100 万用户排序？</p><span id="more"></span><p> 这个问题用归并、快排也能搞定，但时间复杂度最低也是$O(nlongn)$，这次我们学习几种线性排序（Linear sort）：桶排序、计数排序、基数排序，时间复杂度都是$O(n)$。</p><h3 id="桶排序（Bucket-sort）"><a href="#桶排序（Bucket-sort）" class="headerlink" title="桶排序（Bucket sort）"></a>桶排序（Bucket sort）</h3><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了。</p><img data-src="https://static001.geekbang.org/resource/image/98/ae/987564607b864255f81686829503abae.jpg?wh=1142*705" style="zoom:50%;" /><p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><p><strong>桶排序看起来很优秀，那它是不是可以替代我们之前讲的排序算法呢？</strong></p><p>当然是否定的。首先，要排序的数据需要很容易就能划分成 m 个桶，并且，桶与桶之间有着天然的大小顺序。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。</p><p>其次，数据在各个桶之间的分布是比较均匀的。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了。</p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。</p><p>举个例子，有10GB的订单数据需要按照订单金额进行排序（假设金额都是正数），但我们内存有限，只有几百MB，无法一次性加载10GB数据。</p><p>首先可以扫描一遍文件，看订单金额数据范围，假设扫描后得到金额在1元到10万元间，我们将订单金额划分到100个桶里，第一个桶存储1元到1000元之间的订单，第二桶存储1001元到2000元之间的订单，以此类推。每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名（00，01，02…99）。</p><p>理想情况下，订单金额在1元到10万元之间均匀分布， 那订单就会均匀划分到100个文件中，每个小文件存储约100MB数据，再依次对其进行快排排序，等文件都排好序后，再按照文件编号，从小到大依次取出每个文件中的订单数据即可。</p><p>不过，你也发现了，订单按照金额不一定是均匀分布的，假如金额在1元到1000元之间的较多，那还可以将这个区间在此划分为跨度为100元的10个小区间，甚至继续划分，直到所有文件可以读入内存为止。</p><h3 id="计数排序（Counting-sort）"><a href="#计数排序（Counting-sort）" class="headerlink" title="计数排序（Counting sort）"></a>计数排序（Counting sort）</h3><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>现在假设所在省有 50 万考生，如何通过成绩快速排序得出名次呢？考生的满分是 900 分，最小是 0 分，这个数据的范围很小，所以我们可以分成 901 个桶，对应分数从 0 分到 900 分。根据考生的成绩，我们将这 50 万考生划分到这 901 个桶里。桶内的数据都是分数相同的考生，所以并不需要再进行排序。我们只需要依次扫描每个桶，将桶内的考生依次输出到一个数组中，就实现了 50 万考生的排序。因为只涉及扫描遍历操作，所以时间复杂度是 O(n)。</p><p>这就是计数排序的算法思想，跟桶排序非常类似，只是桶的大小粒度不一样。<strong>不过，为什么这个排序算法叫“计数”排序呢？“计数”的含义来自哪里呢？</strong></p><p>要搞明白这个问题，先简化下数据规模，假设只有8个考生，分数在0~5分之间，将其放到一个数组A[8]中：2,5,3,0,2,3,0,3</p><p>用C[6]表示桶，遍历考生分数，容易得到：</p><img data-src="https://i.loli.net/2021/08/05/kT19nlmAj87CShK.jpg" style="zoom:50%;" /><p>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8]中，会保存下标 4，5，6 的位置。</p><img data-src="https://i.loli.net/2021/08/05/fn1N4psSJZb3W26.jpg" style="zoom:50%;" /><p>现在问题是如何快速计算出每个分数的考生在有序数组中对应的存储位置呢？</p><p>我们先对C[6]数组顺序求和，C[k]里存储小于等于分数 k 的考生个数。</p><img data-src="https://i.loli.net/2021/08/05/DnK3VLPW6ywCQbk.jpg" style="zoom:50%;" /><p>我们<strong>从后往前</strong>（为了稳定排序）扫描数组A，比如扫描到3，从数组C中取出下标为3的值7，表示分数小于等于3的考生有7个，即3是数组R的第7个元素，取出3放入数组R中，相应的C[3]减1。依次类推，扫描完整个数组A，数组R中的数据就是按照分数大小有序排序了。</p><img data-src="https://static001.geekbang.org/resource/image/1d/84/1d730cb17249f8e92ef5cab53ae65784.jpg?wh=1142*1522" style="zoom:50%;" /><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a是数组，n是数组大小。假设数组中存储的都是非负整数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">  <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">      max = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max + <span class="number">1</span>]; <span class="comment">// 申请一个计数数组c，下标大小[0,max]</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算每个元素的个数，放入c中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    c[a[i]]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依次累加</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">    c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 临时数组r，存储排序之后的结果</span></span><br><span class="line">  <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">  <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">    r[index] = a[i];</span><br><span class="line">    c[a[i]]--;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将结果拷贝给a数组</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    a[i] = r[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，利用另一个数组来计数的实习方式就是将其称为计数排序的原因。</p><p><strong>计数排序只能用在数据范围不大的场景中，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数。</strong></p><p>比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p><h3 id="基数排序（Radix-sort）"><a href="#基数排序（Radix-sort）" class="headerlink" title="基数排序（Radix sort）"></a>基数排序（Radix sort）</h3><p>我们再来看这样一个排序问题。假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？</p><p>之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？手机号码有 11 位，范围太大，显然不适合用这两种排序算法。针对这个排序问题，就可以用上基础排序了。</p><p>可以先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。先来看张过程分解图：</p><img data-src="https://static001.geekbang.org/resource/image/df/0c/df0cdbb73bd19a2d69a52c54d8b9fc0c.jpg?wh=1142*511" style="zoom:50%;" /><p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p><p>当要排序的数据不是等长的，比如英文单词，可以把所有的单词补齐到相同长度，位数不够可以在后面补“0”。</p><p>总结一下，基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://static001.geekbang.org/resource/image/53/3a/538f4aefb62df6171579293a87d9ca3a.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;如何根据年龄给 100 万用户排序？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://hyacinth.fit/archives/a444b428.html"/>
    <id>https://hyacinth.fit/archives/a444b428.html</id>
    <published>2021-08-04T02:14:24.000Z</published>
    <updated>2021-08-06T03:29:38.623Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://static001.geekbang.org/resource/image/7c/67/7c40ffed3d9263a00af4d83198b54a67.jpg" style="zoom:50%;" /><p>插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</p><span id="more"></span><h3 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h3><p><strong>排序算法的执行效率</strong></p><ul><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数 、低阶</li><li>比较次数和交换（或移动）次数</li></ul><p><strong>排序算法的内存消耗</strong></p><p>我们前面讲过，算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法</p><p><strong>排序算法的稳定性</strong></p><p><strong>稳定性</strong>这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变 – 稳点排序算法 &amp; 不稳定排序算法</p><h3 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h3><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p>下面用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据 4，5，6，3，2，1，从小到大进行排序。第一次冒泡操作的详细过程就是这样。</p><img data-src="https://static001.geekbang.org/resource/image/40/e9/4038f64f47975ab9f519e4f739e464e9.jpg" style="zoom:50%;" /><p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了。</p><img data-src="https://static001.geekbang.org/resource/image/92/09/9246f12cca22e5d872cbfce302ef4d09.jpg" style="zoom:50%;" /><p>实际上，刚讲的冒泡过程还可以优化。当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p><img data-src="https://static001.geekbang.org/resource/image/a9/e6/a9783a3b13c11a5e064c5306c261e8e6.jpg" style="zoom:50%;" /><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在思考上面说的排序算法的三个方面。</p><ol><li>冒泡排序是原地排序算法吗？</li></ol><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法</p><ol start="2"><li>冒泡排序是稳定的排序算法吗？</li></ol><p>在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，当有相邻的两个元素大小相等的时候，我们不做交换，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</p><ol start="3"><li>冒泡排序的时间复杂度是多少？</li></ol><p>最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n2)。</p><p>再来分析下平均情况下的时间复杂度。对于包含n个数据的数组，有n!种排列方式，不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。这里换一种思路，通过“<strong>有序度</strong>”和“<strong>逆序度</strong>”这两个概念来进行分析。</p><p><strong>有序度</strong>是数组中具有有序关系的元素对的个数。有序元素对用数学表达式表示就是这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;&#x3D; a[j], 如果i &lt; j。</span><br></pre></td></tr></table></figure><img data-src="https://static001.geekbang.org/resource/image/a1/20/a1ef4cc1999d6bd0af08d8417ee55220.jpg" style="zoom:50%;" /><p>同理，对于一个倒序排列的数组，比如 6，5，4，3，2，1，有序度是 0；对于一个完全有序的数组，比如 1，2，3，4，5，6，有序度就是 $n*(n-1)/2$，也就是 15。我们把这种完全有序的数组的有序度叫作<strong>满有序度</strong>。</p><p>逆序度的定义正好跟有序度相反。关于这三个概念，我们还可以得到一个公式：逆序度 = 满有序度 - 有序度。我们排序的过程就是一种增加有序度，减少逆序度的过程，最后达到满有序度，就说明排序完成了</p><p>我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4，5，6，3，2，1 ，其中，有序元素对有 (4，5) (4，6)(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 $n*(n-1)/2=15$。</p><img data-src="https://i.loli.net/2021/08/04/rSBdM6AUv7FTuxD.jpg" style="zoom:50%;" /><p>冒泡排序包含两个操作原子，<strong>比较</strong>和<strong>交换</strong>。每交换一次，有序度就加 1。不管算法怎么改进，交换次数总是确定的，即为<em><em>逆序度，也就是$n</em>(n-1)/2$初始有序度</em>*。此例中就是 15–3=12，要进行 12 次交换操作。</p><p>对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行$n*(n-1)/2$​次交换。最好情况下，初始状态的有序度是 $n*(n-1)/2$​，就不需要进行交换。我们可以取个中间值 $n*(n-1)/4$，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>换句话说，平均情况下，需要 $n*(n-1)/4$​ 次交换操作，比较操作肯定要比交换操作多，而复杂度的上限是 $O(n^2)$​，所以平均情况下的时间复杂度就是 $O(n^2)$​。</p><p>这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用</p><h3 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h3><p>一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p><img data-src="https://static001.geekbang.org/resource/image/7b/a6/7b257e179787c633d2bd171a764171a6.jpg" style="zoom:50%;" /><p>首先，我们将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是 4，5，6，1，3，2，其中左侧为已排序区间，右侧是未排序区间。</p><img data-src="https://static001.geekbang.org/resource/image/b6/e1/b60f61ec487358ac037bf2b6974d2de1.jpg" style="zoom:50%;" /><p>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><p>对于不同的查找插入点方法（从头到尾、从尾到头），元素的比较次数是有区别的。但对于一个给定的初始序列，移动操作的次数总是固定的，就等于逆序度。</p><p>为什么说移动次数就等于逆序度呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是$n*(n-1)/2=15$，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4。</p><img data-src="https://static001.geekbang.org/resource/image/fd/01/fd6582d5e5927173ee35d7cc74d9c401.jpg" style="zoom:50%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a表示数组，n表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序空间复杂度为$O(1)$​，是原地排序算法，也是稳定排序算法。最好时间复杂度是$O(n)$​，最坏是$O(n^2)$​，我们在数组中插入一个数据的平均时间复杂度是$O(n)$，所以插入排序循环n次插入操作的平均时间复杂度就是$O(n^2)$。​</p><h3 id="选择排序（Sort）"><a href="#选择排序（Sort）" class="headerlink" title="选择排序（Sort）"></a>选择排序（Sort）</h3><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><img data-src="https://static001.geekbang.org/resource/image/32/1d/32371475a0b08f0db9861d102474181d.jpg" style="zoom:50%;" /><p>选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n2)。但是，选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并和前面的元素交换位置，这样破坏了稳定性。</p><h3 id="为什么插入排序要比冒泡排序更受欢迎呢？"><a href="#为什么插入排序要比冒泡排序更受欢迎呢？" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎呢？"></a>为什么插入排序要比冒泡排序更受欢迎呢？</h3><p>冒泡排序的数据交换要比插入排序的数据移动要复杂，冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个。对于数据规模大的问题，插入排序更有效率。而且插入排序的算法有很大的优化空间，参考[希尔排序](<a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序 - 维基百科，自由的百科全书 (wikipedia.org)</a>)。</p><img data-src="https://static001.geekbang.org/resource/image/ae/fb/ae97df138c98e6c130f76d93c02095fb.jpg" style="zoom:50%;" /><p>再讲两种时间复杂度为 O(nlogn) 的排序算法，<strong>归并排序</strong>和<strong>快速排序</strong>。这两种排序算法适合大规模的数据排序。</p><p>归并排序和快速排序都用到了分治思想，非常巧妙。我们可以借鉴这个思想，来解决非排序的问题，比如：<strong>如何在 O(n) 的时间复杂度内查找一个无序数组中的第 K 大元素？</strong></p><h3 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h3><p>归并排序的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。</p><img data-src="https://static001.geekbang.org/resource/image/db/2b/db7f892d3355ef74da9cd64aa926dc2b.jpg" style="zoom:50%;" /><p>归并排序使用的就是<strong>分治思想</strong>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。</p><p>分治思想跟我们前面讲的递归思想很像。是的，分治算法一般都是用递归来实现的。<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>。</p><p>归并排序的递推公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) &#x3D; merge(merge_sort(p…q), merge_sort(q+1…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;&#x3D; r 不用再继续分解</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 归并排序算法, A是数组，n表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  &#x2F;&#x2F; 递归终止条件</span><br><span class="line">  if p &gt;&#x3D; r  then return</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 取p到r之间的中间位置q</span><br><span class="line">  q &#x3D; (p+r) &#x2F; 2</span><br><span class="line">  &#x2F;&#x2F; 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+1, r)</span><br><span class="line">  &#x2F;&#x2F; 将A[p...q]和A[q+1...r]合并为A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+1...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>merge()函数示意图：</p><img data-src="https://static001.geekbang.org/resource/image/95/2f/95897ade4f7ad5d10af057b1d144a22f.jpg" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+1...r]) &#123;</span><br><span class="line">  var i :&#x3D; p，j :&#x3D; q+1，k :&#x3D; 0 &#x2F;&#x2F; 初始化变量i, j, k</span><br><span class="line">  var tmp :&#x3D; new array[0...r-p] &#x2F;&#x2F; 申请一个大小跟A[p...r]一样的临时数组</span><br><span class="line">  while i&lt;&#x3D;q AND j&lt;&#x3D;r do &#123;</span><br><span class="line">    if A[i] &lt;&#x3D; A[j] &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[i++] &#x2F;&#x2F; i++等于i:&#x3D;i+1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      tmp[k++] &#x3D; A[j++]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 判断哪个子数组中有剩余的数据</span><br><span class="line">  var start :&#x3D; i，end :&#x3D; q</span><br><span class="line">  if j&lt;&#x3D;r then start :&#x3D; j, end:&#x3D;r</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将剩余的数据拷贝到临时数组tmp</span><br><span class="line">  while start &lt;&#x3D; end do &#123;</span><br><span class="line">    tmp[k++] &#x3D; A[start++]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  &#x2F;&#x2F; 将tmp中的数组拷贝回A[p...r]</span><br><span class="line">  for i:&#x3D;0 to r-p do &#123;</span><br><span class="line">    A[p+i] &#x3D; tmp[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序是稳定排序算法</p><p>来分析一下归并排序的时间复杂度，假设对 n 个元素进行归并排序需要的时间是 T(n)，那分解成两个子数组排序的时间都是 T(n/2)。merge() 函数合并两个有序子数组的时间复杂度是 O(n)，归并排序的时间复杂度的计算公式就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C;   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; 2*T(n&#x2F;2) + n   &#x2F;&#x2F; n&gt;1</span><br><span class="line">     &#x3D; 2*(2*T(n&#x2F;4) + n&#x2F;2) + n &#x3D; 4*T(n&#x2F;4) + 2*n</span><br><span class="line">     &#x3D; 4*(2*T(n&#x2F;8) + n&#x2F;4) + 2*n &#x3D; 8*T(n&#x2F;8) + 3*n</span><br><span class="line">     &#x3D; 8*(2*T(n&#x2F;16) + n&#x2F;8) + 3*n &#x3D; 16*T(n&#x2F;16) + 4*n</span><br><span class="line">     ......</span><br><span class="line">     &#x3D; 2^k * T(n&#x2F;2^k) + k * n</span><br><span class="line">     ......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过这样一步一步分解推导，我们可以得到 T(n) = 2^kT(n/2^k)+kn。当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n 。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n 。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。</p><p>从原理分析和伪代码可以看出，归并排序的执行效率与要排序的原始数组的有序程度无关，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p><p>归并排序不是原地排序算法（致命“弱点”）,递归代码的空间复杂度并不能像时间复杂度那样累加，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p><h3 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h3><p>快排的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。</p><p>遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。再使用递归处理思想，用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，直到区间缩小为 1。</p><img data-src="https://static001.geekbang.org/resource/image/4d/81/4d892c3a2e08a17f16097d07ea088a81.jpg" style="zoom:50%;" /><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 快速排序，A是数组，n表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, 0, n-1)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 快速排序递归函数，p,r为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  if p &gt;&#x3D; r then return</span><br><span class="line">  </span><br><span class="line">  q &#x3D; partition(A, p, r) &#x2F;&#x2F; 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-1)</span><br><span class="line">  quick_sort_c(A, q+1, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和归并排序的merge函数类似，这里也有一个partition分区函数，如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p….r]。</p><img data-src="https://static001.geekbang.org/resource/image/66/dc/6643bc3cef766f5b3e4526c332c60adc.jpg" style="zoom:50%;" /><p>我们希望快排是原地排序算法，有一个巧妙地实现思路：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">  pivot :&#x3D; A[r]</span><br><span class="line">  i :&#x3D; p</span><br><span class="line">  for j :&#x3D; p to r-1 do &#123;</span><br><span class="line">    if A[j] &lt; pivot &#123;</span><br><span class="line">      swap A[i] with A[j]</span><br><span class="line">      i :&#x3D; i+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap A[i] with A[r]</span><br><span class="line">  return i</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>图示：</p><img data-src="https://static001.geekbang.org/resource/image/08/e7/086002d67995e4769473b3f50dd96de7.jpg" style="zoom:50%;" /><p>因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</p><p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢?</p><img data-src="https://static001.geekbang.org/resource/image/aa/05/aa03ae570dace416127c9ccf9db8ac05.jpg" style="zoom:50%;" /><p>可以发现，归并排序的处理过程是由下到上的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是由上到下的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题</p><p><strong>快速排序的性能分析</strong></p><p>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)；如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n2)</p><p>刚刚讲了两个极端情况下的时间复杂度，一个是分区极其均衡，一个是分区极其不均衡。它们分别对应快排的最好情况时间复杂度和最坏情况时间复杂度。那快排的平均情况时间复杂度是多少呢？</p><p>假设每次分区操作都将区间分成大小为 9:1 的两个小区间。我们继续套用递归时间复杂度的递推公式，就会变成这样：T(1) = C； n=1时，只需要常量级的执行时间，所以表示为C。T(n) = T(n/10) + T(9*n/10) + n； n&gt;1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(1) &#x3D; C；   n&#x3D;1时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) &#x3D; T(n&#x2F;10) + T(9*n&#x2F;10) + n； n&gt;1</span><br></pre></td></tr></table></figure><p>这个公式的递推求解的过程非常复杂，虽然可以求解，但我不推荐用这种方法。实际上，递归的时间复杂度的求解方法除了递推公式之外，还有递归树。这里直接给你结论：T(n) 在大部分情况下的时间复杂度都可以做到 O(nlogn)，只有在极端情况下，才会退化到 O(n2)。而且，我们也有很多方法将这个概率降到很低。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://static001.geekbang.org/resource/image/7c/67/7c40ffed3d9263a00af4d83198b54a67.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;插入排序和冒泡排序的时间复杂度相同，都是 O(n2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>递归</title>
    <link href="https://hyacinth.fit/archives/c6654282.html"/>
    <id>https://hyacinth.fit/archives/c6654282.html</id>
    <published>2021-08-03T13:27:03.000Z</published>
    <updated>2021-08-03T14:12:49.588Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://static001.geekbang.org/resource/image/e1/f4/e15d9f05aadeb469258016d0901a38f4.jpg" style="zoom:50%;" /><p>现在很多APP都有注册返佣的功能，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。</p><p><strong>那给定一个用户ID，如何查找该用户的“最终推荐人”？</strong></p><span id="more"></span><h3 id="如何理解递归？"><a href="#如何理解递归？" class="headerlink" title="如何理解递归？"></a>如何理解递归？</h3><p>递归是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。</p><p>举个例子，周末带着女票去看电影，她问你咱们坐在第几排啊？电影院太黑没法数，这会递归法就能上场了，你可以问你前面一排的哥们是第几排，你只要在他的数字上加一就能知道了。但是，前面的人也不清楚，所以他也问前面的人，依次前推，知道第一排的人说了答案，然后再一排排传回数字，最终你就能告诉女票位置了。</p><p>这就是一个非常标准的递归求解问题的分解过程，去的过程叫“递”，回来的过程叫“归”。基本上，所有的递归问题都可以用递推公式来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n)&#x3D;f(n-1)+1 其中，f(1)&#x3D;1</span><br></pre></td></tr></table></figure><p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int f(int n) &#123;</span><br><span class="line">  if (n &#x3D;&#x3D; 1) return 1;</span><br><span class="line">  return f(n-1) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归需要满足的三个条件？"><a href="#递归需要满足的三个条件？" class="headerlink" title="递归需要满足的三个条件？"></a>递归需要满足的三个条件？</h3><p>只要问题满足以下三个条件，就可以用递归来解决。</p><ol><li>一个问题的解可以分解为几个子问题的解</li><li>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</li><li>存在递归终止条件</li></ol><h3 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h3><p>最关键的就是<strong>写出递推公式，找到终止条件</strong>。</p><p>举个例子。假设有n个台阶，每次你可以跨越1个台阶或2个台阶，请问走着n个台阶有多少种走法？如果有7个台阶，可以选择2,2,2,1走上去，也可以选择1,2,1,1,2走上去。</p><p>仔细思考，走法可以分为两类，第一步走1个台阶，以及第一步走2个台阶。n个台阶的走法就等于先走1阶后，n-1的走法，加上先走2阶后，n-2个台阶的走法，公式表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) &#x3D; f(n-1)+f(n-2)</span><br></pre></td></tr></table></figure><p>有了递推公式，再来考虑终止条件。当只有一个台阶时，不需要递归，只有一种走法。所以$f(1)=1$​​。这个条件够了吗？我们可以用$n=2，n=3$靠近临界点的数试验。</p><p>$n=2$​时，$f(2)=f(1)+f(0)$。如果终止条件只有$f(1)=1$​，那f(2)​就无法求解了，还需要满足$f(0)=1$，表示走0个台阶有一种走法，但这不符合逻辑。所以，还要把$f(2)=2$​也作为一种终止条件，表示走2个台阶有两种走法，一次走完或两次一步。</p><p>最后得到，递归终止条件就是$f(1)=1，f(2)=2$，当然，可以也应该再拿n=3，n=4来验证是否正确。得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(<span class="number">2</span>) = <span class="number">2</span>;</span><br><span class="line">f(n) = f(n-<span class="number">1</span>)+f(n-<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>转成递归代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，写递归代码的关键就是<strong>找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码</strong>。</p><p>前面电影院的例子比较简单，递归只调用一个分支，但实际问题往往更为复杂，需要分解为多个子问题。</p><p>人脑是有限的，更倾向于平铺直叙的思维方式，不要试图想清楚递和归的过程，这就进入了一个思维误区，重复的事让计算机来完成。</p><p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><p>因此，<strong>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤</strong>。</p><h3 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h3><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险。</p><p><strong>那么，如何避免出现堆栈溢出呢？</strong></p><p>可以通过在代码中限制调用递归的最大深度的方法来解决，递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了。下面代码是伪代码，为了代码简洁，有些边界条件没有考虑，比如 x&lt;=0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度。</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  ++depth；</span><br><span class="line">  <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> f(n-<span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种做法并不能完全解决问题，因为最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h3 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h3><p>除此之外，使用递归时还会出现重复计算的问题。刚才第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的:</p><img data-src="https://static001.geekbang.org/resource/image/e7/bf/e7e778994e90265344f6ac9da39e01bf.jpg" style="zoom:50%;" /><p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。为了避免重复计算，我们可以通过一个数据结构（比如散列表）来保存已经求解过的 f(k)。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了。</p><p>改造代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// hasSolvedList可以理解成一个Map，key是n，value是f(n)</span></span><br><span class="line">  <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">  hasSolvedList.put(n, ret);</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了这两个常见问题，递归还有很多其他问题。在时间效率上，递归代码里多了很多函数调用，当这些函数调用的数量较大时，就会积聚成一个可观的时间成本。在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p><h3 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h3><p>递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p><p>电影院的例子，抛开场景，只看f(n)=f(n-1)+1这个递推公式，可以改写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = ret + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二个例子也可以改写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    ret = pre + prepre;</span><br><span class="line">    prepre = pre;</span><br><span class="line">    pre = ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本上，所有的递归代码都可以改为这种迭代循环的非递归写法，因为递归本身就是借助栈来实现的，如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。</p><p>但是这种思路实际上是将递归改为了“手动”递归，本质并没有变，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h3 id="调试递归"><a href="#调试递归" class="headerlink" title="调试递归"></a>调试递归</h3><ol><li>打印日志发现，递归值。</li><li>结合条件断点进行调试。</li></ol>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://static001.geekbang.org/resource/image/e1/f4/e15d9f05aadeb469258016d0901a38f4.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;现在很多APP都有注册返佣的功能，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那给定一个用户ID，如何查找该用户的“最终推荐人”？&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>队列</title>
    <link href="https://hyacinth.fit/archives/b6c47025.html"/>
    <id>https://hyacinth.fit/archives/b6c47025.html</id>
    <published>2021-08-03T10:28:10.000Z</published>
    <updated>2021-08-03T14:13:49.183Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/08/03/jAIGtd1VcyDXRLP.jpg" style="zoom:50%;" /><p>当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？</p><span id="more"></span><h3 id="如何理解队列？"><a href="#如何理解队列？" class="headerlink" title="如何理解队列？"></a>如何理解队列？</h3><p><strong>先进先出者，就是典型的“队列”</strong></p><p>队列和栈十分相似，基本操作也是两个：**入队 enqueue()<strong>，放一个数据到队列尾部；</strong>出队 dequeue()**，从队列头部取一个元素</p><img data-src="https://static001.geekbang.org/resource/image/9e/3e/9eca53f9b557b1213c5d94b94e9dce3e.jpg" style="zoom:50%;" /><p>所以，队列跟栈一样，也是一种<strong>操作受限的线性表数据结构</strong>。</p><p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；Java concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p><h3 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h3><p>用数组实现的队列叫作<strong>顺序队列</strong>，用链表实现的队列叫作<strong>链式队列</strong>。</p><p>对于栈来说，我们只需要一个栈顶指针就可以了。但是队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾。</p><p>你可以结合下面这张图来理解。当 a、b、c、d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置。</p><img data-src="https://static001.geekbang.org/resource/image/5c/cb/5c0ec42eb797e8a7d48c9dbe89dc93cb.jpg" style="zoom:50%;" /><p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置。</p><img data-src="https://static001.geekbang.org/resource/image/de/0d/dea27f2c505dd8d0b6b86e262d03430d.jpg" style="zoom:50%;" /><p>当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。</p><img data-src="https://i.loli.net/2021/08/03/wB1kazey4TXJsli.jpg" style="zoom:50%;" /><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p>上面用数组实现队列时，当 tail == n，会有数据搬移操作，循环队列就能解决这个问题</p><img data-src="https://i.loli.net/2021/08/03/ulLfAPcW8H29kDx.jpg" style="zoom:50%;" /><p>要想写出没有 bug 的循环队列的实现代码，最关键的是，<strong>确定好队空和队满的判定条件</strong>。</p><p>队列为空的判断条件仍然是 head == tail。但队列满的判断条件就稍微有点复杂了。</p><img data-src="https://static001.geekbang.org/resource/image/3d/ec/3d81a44f8c42b3ceee55605f9aeedcec.jpg" style="zoom:50%;" /><p>就像图中画的队满的情况，tail=3，head=4，n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，当队满时，(tail+1)%n=head。</p><h3 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h3><p><strong>阻塞队列</strong>其实就是在队列基础上增加了阻塞操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><img data-src="https://static001.geekbang.org/resource/image/5e/eb/5ef3326181907dea0964f612890185eb.jpg" style="zoom:50%;" /><p>上述的定义其实就是一个“生产者 - 消费者模型”！是的，我们可以使用阻塞队列，轻松实现一个“生产者 - 消费者模型”！</p><p>这种基于阻塞队列实现的“生产者 - 消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。</p><p>而且不仅如此，基于阻塞队列，我们还可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”。</p><img data-src="https://static001.geekbang.org/resource/image/9f/67/9f539cc0f1edc20e7fa6559193898067.jpg" style="zoom:50%;" /><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/08/03/jAIGtd1VcyDXRLP.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;当我们向固定大小的线程池中请求一个线程时，如果线程池中没有空闲资源了，这个时候线程池如何处理这个请求？是拒绝请求还是排队请求？各种处理策略又是怎么实现的呢？&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="https://hyacinth.fit/archives/1f4ac2fb.html"/>
    <id>https://hyacinth.fit/archives/1f4ac2fb.html</id>
    <published>2021-07-30T06:23:22.000Z</published>
    <updated>2021-08-03T14:12:49.586Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://static001.geekbang.org/resource/image/79/aa/79d1a08a0a016b4648a764fc62bed8aa.jpg" style="zoom:50%;" /><p>后进者先出，先进者后出，这就是典型的“栈”结构。</p><span id="more"></span><h3 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h3><img data-src="https://static001.geekbang.org/resource/image/3e/0b/3e20cca032c25168d3cc605fa7a53a0b.jpg" style="zoom:50%;" /><p>从栈的操作特性上来看，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><p>事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，数组或链表暴露了太多的操作接口，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选“栈”这种数据结构。</p><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">//栈的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为n的数组空间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">    <span class="keyword">this</span>.n = n;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 将item放到下标为count的位置，并且count加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为count-1的数组元素，并且栈中元素个数count减一</span></span><br><span class="line">    String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Stack based upon linked list</span></span><br><span class="line"><span class="string">    基于链表实现的栈(Python) - linked_stack.py</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data: <span class="built_in">int</span>, <span class="built_in">next</span>=<span class="literal">None</span></span>):</span></span><br><span class="line">        self._data = data</span><br><span class="line">        self._next = <span class="built_in">next</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinkedStack</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;A stack based upon singly-linked list.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self._top: Node = <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span>(<span class="params">self, value: <span class="built_in">int</span></span>):</span></span><br><span class="line">        new_top = Node(value)</span><br><span class="line">        new_top._next = self._top</span><br><span class="line">        self._top = new_top</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span>(<span class="params">self</span>) -&gt; Optional[int]:</span></span><br><span class="line">        <span class="keyword">if</span> self._top:</span><br><span class="line">            value = self._top._data</span><br><span class="line">            self._top = self._top._next</span><br><span class="line">            <span class="keyword">return</span> value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>) -&gt; str:</span></span><br><span class="line">        current = self._top</span><br><span class="line">        nums = []</span><br><span class="line">        <span class="keyword">while</span> current:</span><br><span class="line">            nums.append(current._data)</span><br><span class="line">            current = current._next</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot; &quot;</span>.join(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span>]&quot;</span> <span class="keyword">for</span> num <span class="keyword">in</span> nums)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    stack = LinkedStack()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">        stack.push(i)</span><br><span class="line">    print(stack)</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        stack.pop()</span><br><span class="line">    print(stack)</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度均为 O(1)。</p><h3 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h3><p><strong>函数调用栈</strong>：操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p><p><strong>表达式求值</strong>：为方便解释，将算术表达式简化为只包含加减乘除四则运算。</p><p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p><p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>下面将 3+5*8-6 这个表达式的计算过程画成了一张图，结合图来理解刚讲的计算过程。</p><img data-src="https://static001.geekbang.org/resource/image/bc/00/bc77c8d33375750f1700eb7778551600.jpg" style="zoom:50%;" /><p><strong>括号匹配</strong>：我们可以借助栈来检查表达式中的括号是否匹配。假设表达式中只包含三种括号，圆括号 ()、方括号[]和花括号{}，并且它们可以任意嵌套。</p><p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。</p><p>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p><h3 id="如何实习浏览器的前进、后退功能？"><a href="#如何实习浏览器的前进、后退功能？" class="headerlink" title="如何实习浏览器的前进、后退功能？"></a>如何实习浏览器的前进、后退功能？</h3><p>使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="comment"># 引用当前文件夹下的single_linked_list</span></span><br><span class="line">sys.path.append(<span class="string">&#x27;linked_stack.py&#x27;</span>)</span><br><span class="line"><span class="keyword">from</span> linked_stack <span class="keyword">import</span> LinkedStack</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NewLinkedStack</span>(<span class="params">LinkedStack</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._top</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Browser</span>():</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.forward_stack = NewLinkedStack()</span><br><span class="line">        self.back_stack = NewLinkedStack()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">can_back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">open</span>(<span class="params">self, url</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Open new url %s&quot;</span> % url, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        self.forward_stack.push(url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">back</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.forward_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        top = self.forward_stack.pop()</span><br><span class="line">        self.back_stack.push(top)</span><br><span class="line">        print(<span class="string">&quot;back to %s&quot;</span> % top, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.back_stack.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        top = self.back_stack.pop()</span><br><span class="line">        self.forward_stack.push(top)</span><br><span class="line">        print(<span class="string">&quot;forward to %s&quot;</span> % top, end=<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    browser = Browser()</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">    browser.<span class="built_in">open</span>(<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> browser.can_back():</span><br><span class="line">        browser.back()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> browser.can_forward():</span><br><span class="line">        browser.forward()</span><br><span class="line"></span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br><span class="line">    browser.back()</span><br></pre></td></tr></table></figure><h3 id="为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"><a href="#为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？" class="headerlink" title="为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？"></a>为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</h3><p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p><p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p><h3 id="JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？"><a href="#JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？" class="headerlink" title="JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？"></a>JVM内存管理中的“堆栈”概念和文中的“栈”是不是一回事？</h3><p>内存中的堆栈和数据结构堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据存储结构。 内存空间在逻辑上分为三部分：代码区、静态数据区和动态数据区，动态数据区又分为栈区和堆区。 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调度（进程调度）控制代码区执行代码的切换。 静态数据区：存储全局变量、静态变量、常量，常量包括final修饰的常量和String常量。系统自动分配和回收。 栈区：存储运行方法的形参、局部变量、返回值。由系统自动分配和回收。 堆区：new一个对象的引用或地址存储在栈区，指向该对象存储在堆区中的真实数据。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://static001.geekbang.org/resource/image/79/aa/79d1a08a0a016b4648a764fc62bed8aa.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;后进者先出，先进者后出，这就是典型的“栈”结构。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://hyacinth.fit/archives/2362a8ea.html"/>
    <id>https://hyacinth.fit/archives/2362a8ea.html</id>
    <published>2021-07-29T03:21:05.000Z</published>
    <updated>2021-08-05T05:06:10.649Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/07/29/Y576HhpLyZSwtdR.jpg" style="zoom:50%;" /><p>链表（Linked list）有一个经典应用场景：<strong>LRU缓存淘汰算法</strong>。</p><span id="more"></span><p>缓存是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。</p><p>缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、最近最少使用策略 LRU（Least Recently Used）。</p><h3 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h3><p>链表，是通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，常见的有三种链表结构：单链表、双向链表和循环链表。</p><img data-src="https://i.loli.net/2021/07/29/HniWdagVZIUA9MS.jpg" style="zoom:50%;" /><p>先来看<strong>单链表</strong>，所谓的内存块我们称为<strong>“结点”</strong>，为了将结点串起来，每个链表结点除了存储数据外，还要记录下一个结点地址，我们这个记录指针叫做<strong>后继指针next</strong></p><img data-src="https://i.loli.net/2021/07/29/z3OrpVFKA98bLxW.jpg" style="zoom:50%;" /><p>我们习惯性把第一个结点叫做<strong>头结点</strong>，记录链表的基地址，最后一个结点叫做尾结点，指向一个<strong>空地址NULL</strong> 。</p><p>在进行数组的插入、删除操作时，为了保持内存数据的连续性，需要做大量的数据搬移，所以时间复杂度是 O(n)。而在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。</p><img data-src="https://i.loli.net/2021/07/29/7Z5nfTOEFGueJbv.jpg" style="zoom:50%;" /><p>有利就有弊，链表的随机访问效率教数组差，因为需要一个结点一个结点依次遍历，需要 O(n)的时间复杂度。</p><p><strong>循环链表</strong>是一种特殊的单链表，区别在于尾结点是指向链表的头结点。</p><img data-src="https://i.loli.net/2021/07/29/QYUpe2c1oOZSVGt.jpg" style="zoom:50%;" /><p>在实际软件开发中，更加常用的链表结构是另外一种：<strong>双向链表</strong>。它需要额外的两个空间来存储后继结点和前驱结点的地址，占用更多内存空间，但可以支持双向遍历，以此换来操作的灵活性。</p><img data-src="https://i.loli.net/2021/07/29/n3ZDTsVouNEgGvl.jpg" style="zoom:50%;" /><p>要明白双向链表的高效性体现在哪里，我们可以看一下<strong>删除操作</strong>。</p><ul><li>删除结点中“值等于某个给定值”的结点；</li><li>删除给定指针指向的结点。</li></ul><p>第一种情况，单链表和双向链表都需要遍历查找值而后进行删除，仅删除操作复杂度为 O(1)，但遍历查找是主要耗时步骤，复杂度为 O(n)。</p><p>第二种情况，已经明确要删除的结点，而单链表不支持获取前驱结点，仍需要从头遍历，直到 <code>p-&gt;next=q</code>,说明 p 是 q 的前驱结点。双向链表就可以在 O(1) 复杂度内完成，插入、查询操作同理分析。</p><p>在java语言中，LingedHashMap容器就是使用了双向链表结构。</p><p>一个很重要的知识点，<strong>用空间换时间</strong>的设计思想在实际开发中应用广泛。缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><p>将循环链表和双向链表整合到一起，就是一个新的版本：<strong>双向循环链表</strong></p><img data-src="https://i.loli.net/2021/07/29/wZFghGe3OvS8iPs.jpg" style="zoom:50%;" /><h3 id="链表-VS-数组性能对比"><a href="#链表-VS-数组性能对比" class="headerlink" title="链表 VS 数组性能对比"></a>链表 VS 数组性能对比</h3><img data-src="https://i.loli.net/2021/07/29/Iizay4gULP2dmKR.jpg" style="zoom:50%;" /><p>不过，实际软件开发中，不能仅用复杂度分析就决定使用那个数据结构。数组简单易用，在实现上使用的是连续的内存空间，可以借助CPU的缓存机制，预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，对CPU缓存不友好，没法有效预读。</p><p>数组缺点是大小固定，一经声明就要占用连续内存空间，如果数组过小，就要重新申请一个更大的空间，将原数组拷贝进去，非常费时。链表本身没有大小限制，天然支持动态扩容，这也是它与数组最大区别。</p><h3 id="如何实现LRU缓存淘汰算法"><a href="#如何实现LRU缓存淘汰算法" class="headerlink" title="如何实现LRU缓存淘汰算法?"></a>如何实现LRU缓存淘汰算法?</h3><p>通过哈希表辅以双向链表实现</p><ul><li>双向链表按照使用顺序存储键值对，越靠近头部是最近使用的，靠近尾部则是最久未使用的</li><li>哈希表通过缓存数据的键映射到双向链表中的结点位置</li></ul><p>如此便可使用哈希表定位，找出缓存项在双向链表中位置，再将其移到头部即可在 O(1) 时间内完成 get 或者 put 操作</p><ul><li>get 操作，首先判断 key 是否存在<ul><li>如果 key 存在，返回 -1</li><li>如果 key 存在，通过 hash 表定位后将结点移到头部位置，返回结点值</li></ul></li><li>put 操作，首先判断 key 是否存在<ul><li>如果key 存在，更新结点值，将其移动到头部</li><li>如果key 不存在，使用 key 和 value 创建一个新结点，在链表头部添加盖结点，并将key 和结点添加到哈希表中。然后判断双向链表结点数是否超出容量，是则删除尾结点，并删除哈希表中对应项 </li></ul></li></ul><p>Tips：在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。</p><hr><img data-src="https://i.loli.net/2021/07/29/JCDU5BngouvNVYh.jpg" style="zoom:50%;" /><h3 id="如何轻松写出正确的链表代码？"><a href="#如何轻松写出正确的链表代码？" class="headerlink" title="如何轻松写出正确的链表代码？"></a>如何轻松写出正确的链表代码？</h3><p><strong>理解指针或引用的含义</strong></p><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p><p><strong>警惕指针丢失和内存泄漏</strong></p><p>看下面代码，现在需要在结点 a 和相邻的结点 b 之间插入结点 x，假设当前 p 指向结点 a，下面写法就会发生指针丢失和内存泄漏。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next &#x3D; x;  &#x2F;&#x2F; 将p的next指针指向x结点；</span><br><span class="line">x-&gt;next &#x3D; p-&gt;next;  &#x2F;&#x2F; 将x的结点的next指针指向b结点；</span><br></pre></td></tr></table></figure><p>p-&gt;next 指针在完成第一步后已经不再指向结点 b 而是结点 a，第二行代码相当于将 x 赋值给 x-&gt;next。</p><p>插入结点时，一定要注意操作顺序，同理，删除结点时，也一定要记得手动释放内存空间。</p><ul><li>利用哨兵简化实现难度</li></ul><p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。引入哨兵结点后不管链表是否为空，head指针都会指向这个哨兵结点，我们把这种链表叫<strong>带头链表</strong>，没有哨兵结点的链表就叫做<strong>不带头链表</strong>。如此便可统一相同的代码实现逻辑。</p><img data-src="https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg" style="zoom:50%;" /><p>哨兵是用来解决边界问题的，可以理解为它可以减少特殊情况的判断，比如判空、越界等，增加效率。</p><p>代码一：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 边界条件处理，如果a为空，或者n&lt;=0，说明数组中没有数据，就不用while循环比较了</span></span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这里有两个比较操作：i&lt;n和a[i]==key.</span></span><br><span class="line">  <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == key) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在数组a中，查找key，返回key所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n表示数组a的长度</span></span><br><span class="line"><span class="comment">// 我举2个例子，你可以拿例子走一下代码</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 7</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;  n=6 key = 6</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里因为要将a[n-1]的值替换成key，所以要特殊处理这个值</span></span><br><span class="line">  <span class="keyword">if</span> (a[n<span class="number">-1</span>] == key) &#123;</span><br><span class="line">    <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 把a[n-1]的值临时保存在变量tmp中，以便之后恢复。tmp=6。</span></span><br><span class="line">  <span class="comment">// 之所以这样做的目的是：希望find()代码不要改变a数组中的内容</span></span><br><span class="line">  <span class="keyword">char</span> tmp = a[n<span class="number">-1</span>];</span><br><span class="line">  <span class="comment">// 把key的值放到a[n-1]中，此时a = &#123;4, 2, 3, 5, 9, 7&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = key;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// while 循环比起代码一，少了i&lt;n这个比较操作</span></span><br><span class="line">  <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">    ++i;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 恢复a[n-1]原来的值,此时a= &#123;4, 2, 3, 5, 9, 6&#125;</span></span><br><span class="line">  a[n<span class="number">-1</span>] = tmp;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (i == n<span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果i == n-1说明，在0...n-2之间都没有key，所以返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则，返回i，就是等于key值的元素的下标</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比两段代码，在字符串 a 很长的时候，比如几万、几十万，你觉得哪段代码运行得更快点呢？答案是代码二，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句 i，不要小看这一条语句，当累积执行万次、几十万次时，累积的时间就很明显了。</p><p><strong>重点留意边界条件处理</strong></p><ul><li><p>如果链表为空时，代码是否能正常工作？</p></li><li><p>如果链表只包含一个结点时，代码是否能正常工作？</p></li><li><p>如果链表只包含两个结点时，代码是否能正常工作？</p></li><li><p>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</p></li></ul><p><strong>举例画图，辅助思考</strong></p><p>找个具体例子，释放脑容量，进行更多的逻辑思考，有助于思路清晰。比如往单链表中插入一个数据，如图所示：</p><img data-src="https://static001.geekbang.org/resource/image/4a/f8/4a701dd79b59427be654261805b349f8.jpg" style="zoom:50%;" /><p><strong>多写多练，没有捷径</strong></p><p>5个常见的链表操作：</p><ul><li>单链表反转</li><li>链表中环的检测 </li><li>两个有序的链表合并</li><li>删除链表倒数第 n 个结点</li><li>求链表的中间结点</li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/07/29/Y576HhpLyZSwtdR.jpg&quot; style=&quot;zoom:50%;&quot; /&gt;

&lt;p&gt;链表（Linked list）有一个经典应用场景：&lt;strong&gt;LRU缓存淘汰算法&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode</title>
    <link href="https://hyacinth.fit/archives/6096f3d5.html"/>
    <id>https://hyacinth.fit/archives/6096f3d5.html</id>
    <published>2021-07-29T02:48:05.000Z</published>
    <updated>2021-07-29T07:34:48.284Z</updated>
    
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="LeetCode" scheme="https://hyacinth.fit/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="https://hyacinth.fit/archives/340249a9.html"/>
    <id>https://hyacinth.fit/archives/340249a9.html</id>
    <published>2021-07-28T11:02:33.000Z</published>
    <updated>2021-08-03T13:32:47.664Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/07/28/OoNQVyXiz58dxjb.jpg" style="zoom: 50%;" /><p>数组，不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构</p><span id="more"></span><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。</p><img data-src="https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg" style="zoom:50%;" /><p>而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><img data-src="https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg" style="zoom:50%;" /><p>第二个是<strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。</p><h3 id="数组是如何实现根据下标随机访问数组元素的？"><a href="#数组是如何实现根据下标随机访问数组元素的？" class="headerlink" title="数组是如何实现根据下标随机访问数组元素的？"></a>数组是如何实现根据下标随机访问数组元素的？</h3><p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000。</p><img data-src="https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg" style="zoom:50%;" /><p>计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address &#x3D; base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>其中 data_type_size 表示数组中每个元素的大小.。</p><p>数组适合查找操作，支持随机访问，<strong>根据下标随机访问</strong>的时间复杂度为 O(1)</p><h3 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h3><p>先看<strong>插入操作</strong>，假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。那插入操作的时间复杂度是多少呢？</p><p>最好时间复杂度是 O(1)，最坏时间复杂度是 O(n)，平均情况时间复杂度为 (1+2+…n)/n=O(n)。</p><p>而如果数组中存储的数据没有规律，只是当做存储集合，为避免大规模数据迁移，还有个办法就是直接将第 k 位的数据移到数组最后，新元素放到 k 位置。</p><p>再看<strong>删除操作</strong>，复杂度分析过程类似，结果是一样的。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？</p><p>我们再看个例子。数组 a[10]中存储了 8 个元素：a，b，c，d，e，f，g，h。现在，我们要依次删除 a，b，c 三个元素。</p><img data-src="https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg" style="zoom:50%;" /><p>为了避免 d，e，f，g，h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。</p><p>其实这也就是 JVM 标记清除垃圾回收算法的核心思想。数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要学习它背后的思想和处理技巧，这些东西才是最有价值的。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><p><strong>JVM标记清除垃圾回收算法</strong></p><blockquote><p>大多数主流虚拟机采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有 GC（Garbage Collection， 垃圾回收）ROOTS，将所有 GC ROOTS 可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始。<br>不足：1.效率问题。标记和清理效率都不高，但是当知道只有少量垃圾产生时会很高效。2.空间问题。会产生不连续的内存空间碎片</p></blockquote><h3 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h3><p>现在聊聊数据访问越界的问题，先分析以下这段 C 语言代码运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int main(int argc, char* argv[])&#123;</span><br><span class="line">    int i &#x3D; 0;</span><br><span class="line">    int arr[3] &#x3D; &#123;0&#125;;</span><br><span class="line">    for(; i&lt;&#x3D;3; i++)&#123;</span><br><span class="line">        arr[i] &#x3D; 0;</span><br><span class="line">        printf(&quot;hello world\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果并非是三行“hello world”，而是会无限打印（不同编辑器表现可能会不一样）</p><p>编译器按照内存地址<strong>递减</strong>的方式给变量分配内存</p><h3 id="为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？"><a href="#为什么大多数编程语言中，数组要从-0-开始编号，而不是从-1-开始呢？" class="headerlink" title="为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？"></a>为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢？</h3><p>根据寻址公式，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address &#x3D; base_address + (k-1)*type_size</span><br></pre></td></tr></table></figure><p>从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。</p><p>数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以为了减少一次减法操作，数组选择了从 0 开始编号，而不是从 1 开始。</p><p>不过最主要的原因可能是历史原因。C 语言设计者用 0 开始计数数组下标，之后的 Java、JavaScript 等高级语言都效仿了 C 语言，或者说，为了在一定程度上减少 C 语言程序员学习 Java 的学习成本，因此继续沿用了从 0 开始计数的习惯。实际上，很多语言中数组也并不是从 0 开始计数的，比如 Matlab。甚至还有一些语言支持负数下标，比如 Python。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/07/28/OoNQVyXiz58dxjb.jpg&quot; style=&quot;zoom: 50%;&quot; /&gt;

&lt;p&gt;数组，不仅仅是一种编程语言中的数据类型，还是一种最基础的数据结构&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法学习路线</title>
    <link href="https://hyacinth.fit/archives/c754dd43.html"/>
    <id>https://hyacinth.fit/archives/c754dd43.html</id>
    <published>2021-07-27T03:23:32.000Z</published>
    <updated>2021-07-27T12:03:17.464Z</updated>
    
    <content type="html"><![CDATA[<h3 id="路线图"><a href="#路线图" class="headerlink" title="路线图"></a>路线图</h3><img data-src="https://i.loli.net/2021/07/27/W2Ds79noOQjvH43.png" alt="数据结构与算法学习路线"  /><h3 id="学习书单"><a href="#学习书单" class="headerlink" title="学习书单"></a>学习书单</h3><img data-src="https://i.loli.net/2021/07/27/ZIaeVGOrXckR3uY.png" alt="数据结构与算法学习书单"  /><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><img data-src="https://i.loli.net/2021/07/27/INry6zw7fdFkHPo.png" alt="数据结构与算法知识点" style="zoom:67%;" /><hr><p>没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”</p><img data-src="https://i.loli.net/2021/07/27/jGrCabD9t4FOlms.jpg" style="zoom:50%;" /><p>不要浮躁，不要丧失思考能力，不要丧失学习能力</p><img data-src="https://i.loli.net/2021/07/27/3fh5uHRktqopaez.jpg" style="zoom:50%;" /><p>只有做好打硬仗的心理准备，遇到困难才能心态平和</p><img data-src="https://static001.geekbang.org/resource/image/d3/42/d3c715012b855aaca2b186b5cf862642.jpg" style="zoom:50%;" /><p>“放弃”的念头像是一个心魔，它会一直围绕着你</p><img data-src="https://static001.geekbang.org/resource/image/61/f4/6118ba4f07e5c1f8f1a7a0a18ba6f7f4.jpg" style="zoom:50%;" /><p>入门是一个非常漫长和煎熬的过程，谁都逃不过</p><img data-src="https://i.loli.net/2021/07/27/uv6eYGlFdi87PWS.jpg" style="zoom:50%;" /><p>情商比智商更重要。对于很多学科的学习，智商并不是瓶颈，最终能够决定你能达到的高度的，还是情商，而情商中最重要的，我觉得就是逆商（逆境商数，Adversity Quotient），也就是，当你遇到困难时，你会如何去面对，这将会决定你的人生最终能够走多远。</p><img data-src="https://i.loli.net/2021/07/27/ZFXGd6r1wyD249N.jpg" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>复杂度分析</title>
    <link href="https://hyacinth.fit/archives/aaaaf04a.html"/>
    <id>https://hyacinth.fit/archives/aaaaf04a.html</id>
    <published>2021-07-27T02:46:02.000Z</published>
    <updated>2021-07-29T08:16:54.635Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://static001.geekbang.org/resource/image/ed/5a/edc6039771a3bdfa2ff132000710e85a.jpg" style="zoom: 50%;" /><p><strong>如何分析、统计算法的执行效率和资源消耗？</strong></p><p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。</p><span id="more"></span><h3 id="为什么要进行复杂度分析？"><a href="#为什么要进行复杂度分析？" class="headerlink" title="为什么要进行复杂度分析？"></a>为什么要进行复杂度分析？</h3><p>平时跑代码通过统计、监控来得到算法执行的时间和占用的内存大小的统计方法有很大的局限性（也称为<strong>事后统计法</strong>）</p><p><strong>1. 测试结果非常依赖测试环境</strong></p><p>测试环境中硬件的不同会对测试结果有很大的影响</p><p><strong>2. 测试结果受数据规模的影响很大</strong></p><p>对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反映算法的性</p><p>所以，<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>，也就是本文所要讲述的时间、空间复杂度分析方法。</p><h3 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h3><img data-src="https://i.loli.net/2021/07/27/q6WUtBvMd9ZD4O5.png" style="zoom:50%;" /><p>T(n) 表示代码执行的时间，n 表示数据规模的大小，f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p><strong>大 O 时间复杂度</strong>实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h3><p><strong>1.只关注循环执行次数最多的一段代码</strong></p><p>核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度</p><p><strong>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</strong></p><p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p><p><strong>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</strong></p><p>T(n) = T1(n) * T2(n) = O(n*n) = O(n2)</p><h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><img data-src="https://i.loli.net/2021/07/27/jRgEOxP7C6Lst5k.png" style="zoom: 50%;" /><p>对于罗列的复杂度量级，我们可以粗略地分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p><p>我们把时间复杂度为非多项式量级的算法问题叫作 NP（Non-Deterministic Polynomial，非确定多项式）问题。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度在此不展开讲。我们主要来看几种常见的<strong>多项式时间复杂度</strong>。</p><p><strong>1. O(1)</strong></p><p>O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码</p><p><strong>2. O(logn)、O(nlogn)</strong></p><p>通过一个例子说明</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n) &#123; </span><br><span class="line">i = i * <span class="number">2</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p><img data-src="https://i.loli.net/2021/07/27/qab9dmInWu67GDQ.jpg" style="zoom:50%;" /><p>$x=log_2n$，所以，这段代码的时间复杂度就是 $O(log_2n)$。</p><p>而对数之间是可以互相转换的，$log_3n$就等于$ log_32 * log_2n$，所以 $O(log_3n) = O(C * log2n)$，其中$ C=log_32$ 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 $O(Cf(n)) = O(f(n))$。所以，$O(log_2n)$ 就等于 $O(log_3n)$。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为$ O(logn)$。</p><p><strong>3. (m+n)、O(m*n)</strong></p><p>代码的复杂度由两个数据的规模来决定</p><p>加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))</p><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h3><p><strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong></p><p>和时间复杂度分析一样。常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时用不到。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低</p><img data-src="https://i.loli.net/2021/07/27/tiReMnHlyrqVUDY.png" style="zoom: 50%;" /><hr><img data-src="https://static001.geekbang.org/resource/image/9e/ee/9efe0a80fac815101324e1d4de1e49ee.jpg" style="zoom:50%;" /><p><strong>浅析最好、最坏、平均、均摊时间复杂度</strong></p><p>同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的由此区分出四个复杂度方面的分析，<strong>最好情况时间复杂度</strong>（best case time complexity）、<strong>最坏情况时间复杂度</strong>（worst case time complexity）、<strong>平均情况时间复杂度</strong>（average case time complexity）、<strong>均摊时间复杂度</strong>（amortized time complexity）</p><p>先看一个例子，在一个无序的数组（array）中，查找变量 x 出现的位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; n表示数组array的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123; </span><br><span class="line">int i &#x3D; 0; </span><br><span class="line">int pos &#x3D; -1; </span><br><span class="line">for (; i &lt; n; ++i) &#123; </span><br><span class="line">if (array[i] &#x3D;&#x3D; x) &#123; </span><br><span class="line">pos &#x3D; i; break; </span><br><span class="line">&#125; </span><br><span class="line">&#125; </span><br><span class="line">return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最好情况时间复杂度"><a href="#最好情况时间复杂度" class="headerlink" title="最好情况时间复杂度"></a>最好情况时间复杂度</h3><p>在最理想的情况下，执行这段代码的时间复杂度，即 O(1)</p><h3 id="最坏情况时间复杂度"><a href="#最坏情况时间复杂度" class="headerlink" title="最坏情况时间复杂度"></a>最坏情况时间复杂度</h3><p>在最糟糕的情况下，执行这段代码的时间复杂度，即 O(n)</p><h3 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h3><p>在上面这个例子中，查找变量 x 在数组中位置，有 n+1 种情况：<strong>在数组的 0~n-1 位置中</strong>和<strong>不在数组#中</strong>，同时，还要考虑每种情况发生的概率，最终计算过程为：</p><img data-src="https://static001.geekbang.org/resource/image/36/7f/36c0aabdac69032f8a43368f5e90c67f.jpg?wh=718*214" style="zoom: 50%;" /><p>这个值在概率论中称为<strong>加权平均值</strong>，也叫做期望值，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者期望时间复杂度。用大 O 表示法来表示，去掉系数和常量，加权平均时间复杂度仍然是 O(n)。</p><h3 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h3><p>首先，均摊时间复杂度就是一种特殊的平均时间复杂度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; array表示一个长度为n的数组</span><br><span class="line">&#x2F;&#x2F; 代码中的array.length就等于n</span><br><span class="line">int[] array &#x3D; new int[n];</span><br><span class="line">int count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">void insert(int val) &#123;</span><br><span class="line">   if (count &#x3D;&#x3D; array.length) &#123;</span><br><span class="line">      int sum &#x3D; 0;</span><br><span class="line">      for (int i &#x3D; 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">         sum &#x3D; sum + array[i];</span><br><span class="line">      &#125;</span><br><span class="line">      array[0] &#x3D; sum;</span><br><span class="line">      count &#x3D; 1;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   array[count] &#x3D; val;</span><br><span class="line">   ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此例中平均时间复杂度为：</p><img data-src="https://static001.geekbang.org/resource/image/6d/ed/6df62366a60336d9de3bc34f488d8bed.jpg?wh=1142*156" style="zoom:50%;" /><p>这里引入<strong>摊还分析法</strong>，每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路，得到的就是均摊时间复杂度。</p><p>两个条件满足时使用：1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；2）低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</p>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://static001.geekbang.org/resource/image/ed/5a/edc6039771a3bdfa2ff132000710e85a.jpg&quot; style=&quot;zoom: 50%;&quot; /&gt;

&lt;p&gt;&lt;strong&gt;如何分析、统计算法的执行效率和资源消耗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="数据结构与算法" scheme="https://hyacinth.fit/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Excel 使用技巧</title>
    <link href="https://hyacinth.fit/archives/740b22a4.html"/>
    <id>https://hyacinth.fit/archives/740b22a4.html</id>
    <published>2021-06-07T07:56:23.000Z</published>
    <updated>2021-06-07T09:02:08.074Z</updated>
    
    <content type="html"><![CDATA[<h3 id="源数据表"><a href="#源数据表" class="headerlink" title="源数据表"></a>源数据表</h3><ul><li>一维数据</li><li>一个标题行</li><li>字段分类清晰</li><li>数据属性完整</li><li>数据连续</li><li>无合并单元格</li><li>无合计行</li><li>无分隔行 / 列</li><li>数据区域中无空白单元格</li><li>单元格内容禁用短语或句子</li></ul><span id="more"></span><h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><h4 id="移动行列位置"><a href="#移动行列位置" class="headerlink" title="移动行列位置"></a>移动行列位置</h4><ul><li>选中行或列后，按 Shift 拖动到指定行列位置</li></ul><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul><li>Ctrl + Enter  批量修改单元格</li><li>Ctrl + ;  当前日期</li><li>Ctrl + Shift + ;  当前时间 16:10</li><li>Alt + =  自动求和</li><li>Ctrl + A   输入函数名称后，调出函数面板</li><li>Shift + F3  插入函数</li><li>F2  使单元格进入编辑状态</li><li>F4  使单元格引用在相对、绝对、混合引用中循环切换</li><li>F9  是Excel进行一次计算，对象可以是引用数据区域，函数或公式</li><li>Ctrl + `  公式单元格从显示结果切换到显示公式</li></ul><h4 id="批量取消合并单元格"><a href="#批量取消合并单元格" class="headerlink" title="批量取消合并单元格"></a>批量取消合并单元格</h4><ul><li>选中数据点击取消合并单元格</li><li>F5定位空值数据</li><li>输入公式 “=B2”（当前单元格上一格坐标）</li><li>Ctrl + Enter 批量录入 </li></ul><h4 id="“切”和“拼”"><a href="#“切”和“拼”" class="headerlink" title="“切”和“拼”"></a>“切”和“拼”</h4><ul><li>切：数据 &gt; 分列</li><li>拼：=B2&amp;C2</li></ul><h4 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h4><ul><li>=A2=TODAY()</li></ul><blockquote><p>确保当天录入数据，结合保护工作表可防止修改（exc. 修改计算机日期可以达目的）</p></blockquote><ul><li>=LEN(A1)&lt;&gt;0</li></ul><blockquote><p>但A1单元格有数据时才允许录入，确保数据按序录入</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="VLOOKUP"><a href="#VLOOKUP" class="headerlink" title="VLOOKUP"></a>VLOOKUP</h4><p> VLOOKUP (要查找的项、要查找位置、包含要返回的值的单元格区域中的列号、返回近似或精确匹配 - 指示为 1/TRUE 或 0/FALSE)  </p><ul><li>普通查找</li></ul><blockquote><p>=VLOOKUP(E2,$B$1:$C$15,2,0) </p></blockquote><ul><li>屏蔽错误值查找</li></ul><blockquote><p>=IFERROR(VLOOKUP(E2,$A$1:$C$15,3,0),”查找不到”) </p></blockquote><ul><li>逆向查找</li></ul><blockquote><p>=VLOOKUP(E2,IF({1,0},$B$2:$B$15,$A$2:$A$15),2,0)<br>IF{1,0}，就是把1对应的范围和0对应的范围组合成新的区域。 </p></blockquote><ul><li>按顺序返回多列值内容</li></ul><blockquote><p>=VLOOKUP($E2,$A$1:$C$15,COLUMN(B1),0) </p></blockquote><ul><li>多条件查询</li></ul><blockquote><p>=VLOOKUP(E2&amp;F2,IF({1,0},$A$2:$A$15&amp;$B$2:$B$15,$C$2:$C$15),2,0)<br>此处的IF{1,0}的用法是把A2:A15及B2:B5的区域合并成一个区域使用 </p></blockquote><ul><li>一对多查询</li></ul><blockquote><p>查询一个部门对应所有人员数<br>首先添加辅助列， =B2&amp;COUNTIF($B$2:B2,B2) ，确保用 VLOOKUP 函数查找值是唯一的=IFERROR(VLOOKUP($G$2&amp;ROW(A1),$A$1:$C$27,3,0),””) </p></blockquote><ul><li>VLOOKUP + Match</li></ul><blockquote><p>MATCH(查找的值，查找的区域，0为精确匹配)，实现的结果是返回查找值在查找区域的第几行第几列<br>=VLOOKUP(A20,$A$2:$M$16,MATCH(B20,$A$2:$M$2,0),0) </p></blockquote><ul><li>VLOOKUP + 通配符查找</li></ul><blockquote><p>=VLOOKUP(“<em>“&amp;C2&amp;”</em>“,$A$1:$A$6,1,0) </p></blockquote><h4 id="MATCH"><a href="#MATCH" class="headerlink" title="MATCH"></a>MATCH</h4><p> MATCH（lookup_value,lookuparray,match-type） </p><blockquote><p>match-type： 1或省略，查找小于或等于指定内容最大值，数据必须升序排列；0，查找等于指定内容的第一个值；-1或省略，查找大于或等于指定内容最大值，数据必须降序排列</p></blockquote><h4 id="ROW"><a href="#ROW" class="headerlink" title="ROW"></a>ROW</h4><p>row(reference) </p><blockquote><p>返回 reference 行数， 若无参数，则返回当前行数</p></blockquote><h4 id="MOD"><a href="#MOD" class="headerlink" title="MOD"></a>MOD</h4><p>MOD(number, divisor) </p><blockquote><p>求余数</p></blockquote><h4 id="INDEX"><a href="#INDEX" class="headerlink" title="INDEX"></a>INDEX</h4><p>INDEX(array, row_num, [column_num])</p><blockquote><p>返回由行号和列号索引选中的表或数组中元素的值 </p></blockquote><h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><p> RANK(number,ref,[order]) </p><blockquote><p> 返回一列数字的数字排位 </p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;源数据表&quot;&gt;&lt;a href=&quot;#源数据表&quot; class=&quot;headerlink&quot; title=&quot;源数据表&quot;&gt;&lt;/a&gt;源数据表&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一维数据&lt;/li&gt;
&lt;li&gt;一个标题行&lt;/li&gt;
&lt;li&gt;字段分类清晰&lt;/li&gt;
&lt;li&gt;数据属性完整&lt;/li&gt;
&lt;li&gt;数据连续&lt;/li&gt;
&lt;li&gt;无合并单元格&lt;/li&gt;
&lt;li&gt;无合计行&lt;/li&gt;
&lt;li&gt;无分隔行 / 列&lt;/li&gt;
&lt;li&gt;数据区域中无空白单元格&lt;/li&gt;
&lt;li&gt;单元格内容禁用短语或句子&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Excel" scheme="https://hyacinth.fit/categories/Excel/"/>
    
    
    <category term="Skill" scheme="https://hyacinth.fit/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>Python 批量重命名文件</title>
    <link href="https://hyacinth.fit/archives/e6a92538.html"/>
    <id>https://hyacinth.fit/archives/e6a92538.html</id>
    <published>2021-06-07T03:25:26.000Z</published>
    <updated>2021-06-14T04:30:30.161Z</updated>
    
    <content type="html"><![CDATA[<p>使用 python 遍历文件目录，批量重命名文件，已支持功能包括</p><ul><li>添加前后缀，支持默认序列（输入 seq ）和自定义</li><li>选择文件类型</li><li>选择是否遍历子目录</li><li>选择是否保留原文件名（python读取文件名顺序与文件管理器不同）</li><li>如果已存在序列，可使用正则替换序列格式</li></ul><p><img data-src="https://i.loli.net/2021/06/07/s6bzIfUTL7S5N4r.png"></p><span id="more"></span><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prompt_info</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        Prefix/Suffix: When &quot;seq&quot; is input, the auto-increasing sequence is output;</span></span><br><span class="line"><span class="string">        Use spaces to distinguish the file type you entered;</span></span><br><span class="line"><span class="string">        Replace existing sequence by regular</span></span><br><span class="line"><span class="string">        &#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_boolean</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">if</span> s == <span class="string">&#x27;y&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;yes&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> s == <span class="string">&#x27;n&#x27;</span> <span class="keyword">or</span> s == <span class="string">&#x27;no&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># return get_boolean(input(&#x27;Please enter y(yes) or n(no): &#x27;))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_re</span>(<span class="params">s</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenameFiles</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;docstring for RenameFiles&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(RenameFiles, self).__init__()</span><br><span class="line"></span><br><span class="line">        prompt_info()</span><br><span class="line"></span><br><span class="line">        self.desPath = <span class="string">&#x27;C:\\Users\\MSI-PC\\Desktop\\desktop-pet\\images\\meizi&#x27;</span></span><br><span class="line">        self.oriPath = <span class="string">&#x27;C:\\Users\\MSI-PC\\Desktop\\desktop-pet\\images\\meizi&#x27;</span></span><br><span class="line">        <span class="comment"># 文件前缀</span></span><br><span class="line">        self.prefix = <span class="built_in">input</span>(<span class="string">&#x27;Please enter the file name prefix: &#x27;</span>)</span><br><span class="line">        <span class="comment"># 文件后缀</span></span><br><span class="line">        self.suffix = <span class="built_in">input</span>(<span class="string">&#x27;Please enter the file name suffix: &#x27;</span>)</span><br><span class="line">        <span class="comment"># 是否保留原文件名</span></span><br><span class="line">        self.is_keep = get_boolean(<span class="built_in">input</span>(<span class="string">&#x27;whether to keep the original file name(y/n: &#x27;</span>))</span><br><span class="line">        <span class="comment"># 使用正则替换已存在序列</span></span><br><span class="line">        self.pattern = <span class="built_in">str</span>(<span class="built_in">input</span>(<span class="string">&#x27;Please enter the re pattern: &#x27;</span>))</span><br><span class="line">        <span class="comment"># 文件类型</span></span><br><span class="line">        self.file_type = <span class="built_in">list</span>(<span class="built_in">input</span>(<span class="string">&#x27;Please enter the file type(separated by spaces): &#x27;</span>).split())</span><br><span class="line">        <span class="keyword">if</span> self.file_type <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> self.file_type == []:  <span class="comment"># 默认全部类型</span></span><br><span class="line">            self.file_type = [<span class="string">&#x27;*&#x27;</span>]</span><br><span class="line">        print(<span class="string">&#x27;pattern: &#x27;</span>, self.pattern, <span class="string">&#x27;file_type: &#x27;</span>, self.file_type)</span><br><span class="line">        <span class="comment"># 是否遍历子目录</span></span><br><span class="line">        self.sub_dir = get_boolean(<span class="built_in">input</span>(<span class="string">&#x27;Whether to traverse subdirectories(y/n): &#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Modify file names in batches</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">rename</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> root, dirs, names <span class="keyword">in</span> os.walk(self.oriPath):</span><br><span class="line">            <span class="keyword">for</span> name <span class="keyword">in</span> names:</span><br><span class="line">                file_name = os.path.splitext(name)[<span class="number">0</span>]</span><br><span class="line">                ext = os.path.splitext(name)[<span class="number">1</span>]</span><br><span class="line">                ori_path = os.path.join(root, name)</span><br><span class="line">                <span class="keyword">if</span> self.file_type <span class="keyword">and</span> (<span class="string">&#x27;*&#x27;</span> <span class="keyword">in</span> self.file_type <span class="keyword">or</span> ext[<span class="number">1</span>:] <span class="keyword">in</span> self.file_type):</span><br><span class="line">                    <span class="comment"># 目标命名</span></span><br><span class="line">                    des_name = (self.prefix <span class="keyword">if</span> self.prefix != <span class="string">&#x27;seq&#x27;</span> <span class="keyword">else</span> <span class="built_in">str</span>(count + <span class="number">1</span>) + <span class="string">&#x27;_&#x27;</span>) + (</span><br><span class="line">                        re.sub(self.pattern, <span class="keyword">lambda</span> x: re.findall(<span class="string">r&#x27;\d+&#x27;</span>, x.group(<span class="number">0</span>))[<span class="number">0</span>],</span><br><span class="line">                               file_name) <span class="keyword">if</span> self.is_keep <span class="keyword">else</span> <span class="string">&#x27;&#x27;</span>) + (</span><br><span class="line">                                   self.suffix <span class="keyword">if</span> self.suffix != <span class="string">&#x27;seq&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;_&#x27;</span> + <span class="built_in">str</span>(count + <span class="number">1</span>)) + ext</span><br><span class="line"></span><br><span class="line">                    move_path = os.path.join(self.desPath, des_name)</span><br><span class="line">                    <span class="keyword">if</span> name != os.path.basename(__file__):  <span class="comment"># 防止重命名本文件</span></span><br><span class="line">                        <span class="keyword">try</span>:</span><br><span class="line">                            os.rename(ori_path, move_path)</span><br><span class="line">                            count += <span class="number">1</span></span><br><span class="line">                            print(name + <span class="string">&#x27; 已重命名为 &#x27;</span> + des_name)</span><br><span class="line">                        <span class="keyword">except</span> FileExistsError:</span><br><span class="line">                            print(name + <span class="string">&#x27;更名失败! 已有同名文件存在：&#x27;</span> + move_path)</span><br><span class="line">                        <span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">                            print(<span class="string">&#x27;目标文件夹不存在，请检查后重试&#x27;</span>)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self.sub_dir:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">&#x27;共有 &#x27;</span> + <span class="built_in">str</span>(count) + <span class="string">&#x27; 个文件更名成功&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main = RenameFiles()</span><br><span class="line">    main.rename()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 python 遍历文件目录，批量重命名文件，已支持功能包括&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;添加前后缀，支持默认序列（输入 seq ）和自定义&lt;/li&gt;
&lt;li&gt;选择文件类型&lt;/li&gt;
&lt;li&gt;选择是否遍历子目录&lt;/li&gt;
&lt;li&gt;选择是否保留原文件名（python读取文件名顺序与文件管理器不同）&lt;/li&gt;
&lt;li&gt;如果已存在序列，可使用正则替换序列格式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/07/s6bzIfUTL7S5N4r.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hyacinth.fit/categories/Python/"/>
    
    
    <category term="Skill" scheme="https://hyacinth.fit/tags/Skill/"/>
    
  </entry>
  
  <entry>
    <title>Ctrl + D</title>
    <link href="https://hyacinth.fit/archives/49905.html"/>
    <id>https://hyacinth.fit/archives/49905.html</id>
    <published>2021-06-05T08:56:41.000Z</published>
    <updated>2021-07-28T11:24:02.936Z</updated>
    
    <content type="html"><![CDATA[<img data-src="https://i.loli.net/2021/06/06/IPuV6z1y24rSGws.png"  /><center>聚合各领域链接，资源、博客、工具、素材等</center><span id="more"></span><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul><li><a href="https://material.io/">Material Design</a></li><li><a href="https://www.uplabs.com/material">Material Design, Daily - MaterialUp - MaterialUp</a></li><li><a href="https://www.uplabs.com/">Uplabs</a></li><li><a href="https://github.com/feelschaotic/AndroidKnowledgeSystem">AndroidKnowledgeSystem</a></li><li><a href="https://github.com/LisaDziuba/Awesome-Design-Tools">Awesome-Design-Tools</a></li><li><a href="https://github.com/wasabeef/awesome-android-ui">Awesome-Android-UI</a></li><li><a href="http://www.jcodecraeer.com/">泡在网上的日子</a></li><li><a href="http://www.see-source.com/">看源社区</a></li><li><a href="https://www.qcgzxw.cn/">小文’s blog</a></li><li><a href="https://github.com/FishInWater-1999/android_interviews">android interviews </a></li><li><a href="https://www.25xt.com/appdesign/12385.html">网易云音乐视觉设计规范文档</a></li></ul><h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><ul><li><a href="https://github.com/justjavac/free-programming-books-zh_CN">计算机免费书籍</a></li><li><a href="https://codepen.io/">CodePen</a></li><li><a href="https://codelabs.developers.google.com/">Codelabs</a></li><li><a href="https://codingpy.com/books/thinkpython2/index.html">Think Python 2e</a></li><li><a href="https://github.com/kdn251/interviews">interviews</a></li><li><a href="https://github.com/gto76/python-cheatsheet">python 语法速查</a></li><li><a href="https://blog.csdn.net/andrewniu/article/details/80566277">汇编语言指令</a></li><li><a href="https://github.com/sdmg15/Best-websites-a-programmer-should-visit">Best-websites-a-programmer-should-visit</a></li></ul><h2 id="Blog"><a href="#Blog" class="headerlink" title="Blog"></a>Blog</h2><ul><li><a href="https://cangshui.net/">沧水的博客</a></li><li><a href="http://www.spiderpy.cn/blog/">烂笔头-博客</a></li><li><a href="https://github.com/b3log">B3log</a></li><li><a href="http://typecho.org/">typech0</a></li><li><a href="https://www.qcgzxw.cn/">小文‘s blog</a></li><li><a href="http://lovenight.github.io/">岁月如歌</a></li><li><a href="https://www.dogfight360.com/blog/">羽翼城个人博客</a></li></ul><h2 id="短视频素材"><a href="#短视频素材" class="headerlink" title="短视频素材"></a>短视频素材</h2><p><strong>视频素材</strong></p><ul><li><a href="https://www.videvo.net/">videvo</a></li><li><a href="https://www.free-video-footage.com/">free-video</a></li><li><a href="https://www.jijidown.com/">唧唧-b站视频下载</a></li><li><a href="https://www.pexels.com/videos">pexels</a></li><li><a href="https://www.videezy.com/">videezy</a></li></ul><p><strong>图片素材</strong></p><ul><li><a href="https://www.pexels.com/videos">pexels</a></li><li><a href="https://www.lanrentuku.com/">懒人图库</a></li><li><a href="https://www.unsplash.com/">Unsplash</a></li><li><a href="https://www.hippopx.com/">Hippopx</a></li><li><a href="https://www.colorhub.me/">ColorHub</a></li><li><a href="https://www.foodiesfeed.com/">Foodiefeed</a></li></ul><p><strong>音频素材</strong></p><ul><li><a href="https://www.audiolibrary.com.co/">Audio Library</a></li><li><a href="sourl.cn/hthUQX">Adobe Audition</a></li><li><a href="https://freemusicarchive.org/search">Free Music Archive</a></li><li><a href="https://www.aigei.com/">爱给网</a></li><li><a href="https://www.ear0.com/">耳聆网</a></li><li><a href="https://1soundfx.com/">1Soundfx</a></li></ul><p><strong>文案脚本素材</strong></p><ul><li><a href="https://link.zhihu.com/?target=http://www.juben98.com/">剧本网</a></li><li><a href="https://link.zhihu.com/?target=http://www.juben108.com/">原创剧本网</a></li><li><a href="https://link.zhihu.com/?target=https://www.1bianju.com/">华语编剧网</a></li><li><a href="https://link.zhihu.com/?target=https://www.juben68.com/">剧本联盟</a></li></ul><p><strong>选题素材来源</strong></p><ul><li>百度搜索风云榜</li><li>百度指数</li><li>微博热搜</li><li>新媒体管家—热点中心</li><li>TooBigData</li><li>微信指数</li></ul><h2 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h2><ul><li><a href="https://blog.csdn.net/wenxuhonghe">博客-爬虫</a></li><li><a href="https://github.com/Kr1s77/Python-crawler-tutorial-starts-from-zero">python-crawler-tutorial</a></li><li><a href="https://github.com/Kr1s77/awesome-python-login-model">awesome-python-login</a></li></ul><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ul><li><a href="https://github.com/youzan/vant-weapp">Vant Weapp</a></li><li><a href="https://github.com/Tencent/weui/">WeUI</a></li><li><a href="https://github.com/Tencent/wepy">Wepy</a></li><li><a href="https://github.com/alsey/wxbarcode">条码、二维码</a></li><li><a href="https://github.com/jasondu/wxa-plugin-canvas/">二维码海报</a></li><li><a href="https://github.com/gooking/apifm-wxapi">api接口</a></li></ul><h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul><li><a href="http://www.nicetool.net/">在线工具大全</a></li><li><a href="http://magnet.chongbuluo.com/">资源搜索</a></li><li><a href="https://www.appinn.com/">小众软件</a></li><li><a href="https://yunpanzhushou.com/">云盘助手</a></li><li><a href="http://www.mvcat.com/">电影推荐-MVCAT</a></li><li><a href="https://kepler.gl/">地图可视化编辑器</a></li><li><a href="https://shields.io/">Shields.io/</a></li><li><a href="https://wangyasai.github.io/Stars-Emmision/">Star Emmision</a></li><li><a href="https://magi.com/">Magi</a></li><li><a href="https://www.wenshushu.cn/">文叔叔</a></li><li><a href="https://6pan.cn/">6pan</a></li><li><a href="https://codeif.xinke.org.cn/">CodeIF-代码命名</a></li><li><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">Emoji</a></li><li><a href="https://www.nocmd.com/">NoCmd</a></li><li><a href="https://github.com/NGC-HenryLee/NGC.SS.JJ/">jj</a></li><li><a href="https://cowtransfer.com/">奶牛快传</a></li><li><a href="https://www.logosc.cn/">LOGO神器</a>(F12找logo对应svg代码，右键copy element)</li><li><a href="https://github.com/iptv-org/iptv">iptv</a></li><li><a href="https://uigradients.com/">渐变色</a></li><li><a href="https://github.com/bannedbook/fanqiang">fanqiang</a></li><li><a href="https://www.linshiyouxiang.net/">临时邮箱</a></li><li><a href="https://encycolorpedia.cn/">十六进制代码颜色表</a></li><li><a href="https://xbeibeix.com/api/bilibili/">B站视频下载</a></li><li><a href="https://www.maxthon.cn/mx5/uumail/">百变邮箱</a></li><li><a href="https://steamworkshopdownloader.io/">创意工坊下载</a></li><li><a href="https://afcano.com/">英文起名</a></li><li><a href="http://t.cn/AiT9X7mV">代码截图 Chrome 应用</a></li><li><a href="https://carbon.now.sh/">代码截图</a></li><li><a href="https://sketchviz.com/new">手绘图</a></li></ul><h2 id="开眼"><a href="#开眼" class="headerlink" title="开眼"></a>开眼</h2><ul><li><a href="http://ddrk.me/">低端影视</a></li><li><a href="https://tophub.today/">今日热榜</a></li><li><a href="https://www.cheat8.com/">奇特吧</a></li><li><a href="https://getitfree.cn/">正版中国</a></li><li><a href="http://yx.bsh.me/">异星</a></li><li><a href="https://www.ghpym.com/category/all/android/xposed">果核剥壳</a></li><li><a href="https://5kindle.com/">子午书简</a></li><li><a href="https://www.overwolf.com/">Overwolf</a></li></ul><h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul><li><a href="https://zhutix.com/">致美化</a></li><li><a href="https://www.25xt.com/">25学堂-ui素材</a></li><li><a href="https://huaban.com/">花瓣网</a></li><li><a href="https://github.com/Tencent/QMUI_Android">QMUI_Android</a></li><li><a href="https://www.canva.cn/templates/">Canva</a></li></ul><h2 id="Algorithms"><a href="#Algorithms" class="headerlink" title="Algorithms"></a>Algorithms</h2><ul><li><p><a href="https://github.com/xtaci/algorithms">C++</a></p></li><li><p><a href="https://github.com/trekhleb/javascript-algorithms">Javascript</a></p></li><li><p><a href="https://github.com/TheAlgorithms/Python">Python</a></p></li></ul><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><ul><li><a href="https://www.awesomes.cn/">Web前端开发资源库</a></li><li><a href="https://css-tricks.com/centering-css-complete-guide/">CSS居中</a></li><li><a href="https://www.30secondsofcode.org/css/p/1">30 Seconds of CSS</a></li><li><a href="https://www.patreon.com/onlinetutorials/posts">Online Tutorials(Paid)</a></li></ul><p><strong>Vue</strong></p><ul><li><a href="https://www.jeffjade.com/2017/03/11/120-how-to-write-vue-better/#fromHistory">如何写一手漂亮的Vue</a></li><li><a href="https://ppt.baomitu.com/d/52096df3#/1">Vue2.x 开发Web应用 – ppt</a></li></ul><h2 id="Art"><a href="#Art" class="headerlink" title="Art"></a>Art</h2><ul><li><p><a href="https://logo.shapefactory.co/">Logo by ShapeFactor</a></p></li><li><p><a href="https://www.artic.edu/collection">Discover Art &amp; Artists</a></p></li><li><p><a href="https://unsplash.com/">Unsplash</a></p></li><li><p><a href="https://www.deviantart.com/">DeviantArt</a></p></li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git 教程</a></li><li><a href="https://learngitbranching.js.org/">Git 练习平台</a></li></ul><h2 id="Articles"><a href="#Articles" class="headerlink" title="Articles"></a>Articles</h2><ul><li><a href="http://www.jcodecraeer.com/a/anzhuokaifa/2017/1020/8625.html?1508484926">MVP</a></li><li><a href="https://www.jianshu.com/p/e7d5c7bda783">EventBus</a></li><li><a href="https://gank.io/post/560e15be2dca930e00da1083">RxJava</a></li><li><a href="https://mp.weixin.qq.com/s/UAEgdC2EtqSpEqvog0aoZQ">RxJava系列</a></li><li><a href="https://www.jianshu.com/p/6d1d063e0148">Context</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures">闭包</a></li><li><a href="https://muyangmin.github.io/glide-docs-cn/">Glide</a></li></ul><h2 id="Game"><a href="#Game" class="headerlink" title="Game"></a>Game</h2><ul><li><a href="http://www.secha.net/">找色差</a></li><li><a href="https://www.wuziqi.org.cn/">五子棋</a></li><li><a href="https://www.heibaiqi.com.cn/">黑白棋</a></li><li><a href="http://www.2043.cn/">2048</a></li><li><a href="https://www.yibilian.cn/">一笔连</a></li><li><a href="https://www.hannuota.cn/">汉诺塔</a></li></ul><h2 id="Points"><a href="#Points" class="headerlink" title="Points"></a>Points</h2><ul><li><a href="https://github.com/JessYanCoding/AndroidAutoSize">屏幕适配</a></li><li><a href="https://github.com/Justson/AgentWeb">WebView</a></li><li><a href="https://github.com/dwqs/blog/issues/51">vue中优雅使用第三方库</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;img src=&quot;https://i.loli.net/2021/06/06/IPuV6z1y24rSGws.png&quot;  /&gt;

&lt;center&gt;聚合各领域链接，资源、博客、工具、素材等&lt;/center&gt;</summary>
    
    
    
    <category term="Favorite" scheme="https://hyacinth.fit/categories/Favorite/"/>
    
    
    <category term="Tools" scheme="https://hyacinth.fit/tags/Tools/"/>
    
    <category term="Learning" scheme="https://hyacinth.fit/tags/Learning/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 使用及问题总结</title>
    <link href="https://hyacinth.fit/archives/58793.html"/>
    <id>https://hyacinth.fit/archives/58793.html</id>
    <published>2021-06-05T08:56:41.000Z</published>
    <updated>2021-07-27T06:23:46.798Z</updated>
    
    <content type="html"><![CDATA[<h3 id="快速启动"><a href="#快速启动" class="headerlink" title="快速启动"></a>快速启动</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><span id="more"></span><p>blog 文件夹目录如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml   &#x2F;&#x2F; 网站配置信息</span><br><span class="line">├── package.json  &#x2F;&#x2F; 应用程序信息</span><br><span class="line">├── scaffolds     &#x2F;&#x2F; 模板文件夹</span><br><span class="line">├── source        &#x2F;&#x2F; 资源文件夹</span><br><span class="line">|   ├── _drafts   &#x2F;&#x2F; 草稿</span><br><span class="line">|   └── _posts    &#x2F;&#x2F; 发布的文件</span><br><span class="line">└── themes        &#x2F;&#x2F; 主题</span><br></pre></td></tr></table></figure><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>新建文章 <code>hexo new [layout] &lt;title&gt;</code></p><blockquote><p>没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来</p></blockquote><p>启动服务 <code>hexo s(server) [--debug]</code></p><p>生成静态文件 <code>hexo g(generate)</code></p><p>生成部署 <code>hexo g -d </code></p><p>发布草稿 <code>hexo publish [layout] &lt;filename&gt;</code></p><p>清除缓存（db.json）和静态文件（public）<code>hexo clean</code></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><p>在头部添加以下信息：</p><blockquote><p>password: 123<br>abstract: 密码：123<br>message: Enter the password to view the article</p></blockquote><h3 id="Warning"><a href="#Warning" class="headerlink" title="Warning"></a>Warning</h3><ul><li><p>Accessing non-existent property xxxx of module exports inside circular dependency</p><p>使用命令 <code>npx cross-env NODE_OPTIONS=&quot;--trace-warnings&quot; hexo s</code>跟踪错误，发现是nib 这个包里的 stylus 的问题，网上说的降低 node 版本是一种方法，但我们不能如此将就。</p><p>nib 中的 dependencies 为 <code>&quot;stylus&quot;: &quot;0.54.5&quot;</code>，nib最后一次更新已经是2016年了，指望不了别人，就靠自己吧</p><p>始终相信，同样的问题，别人一定提出过，查官方 issues，看到有人已经<a href="https://github.com/stylus/stylus/pull/2538">修复</a>，并且推到了 <a href="https://github.com/stylus/stylus/pull/2538/commits/16e2a6c6f96f80b0d700411879f1c13991a0a1a5">dev</a> 上，几句代码我们就直接改吧</p></li></ul><p>​      打开 node_modules\nib\node_modules\stylus\lib\nodes\index.js 在前面添加以下代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exports</span>.lineno = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.column = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">exports</span>.filename = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;快速启动&quot;&gt;&lt;a href=&quot;#快速启动&quot; class=&quot;headerlink&quot; title=&quot;快速启动&quot;&gt;&lt;/a&gt;快速启动&lt;/h3&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo-cli -g&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo init blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd blog&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;hexo server&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Web" scheme="https://hyacinth.fit/categories/Web/"/>
    
    
    <category term="Hexo" scheme="https://hyacinth.fit/tags/Hexo/"/>
    
    <category term="NexT" scheme="https://hyacinth.fit/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>Python 爬取百度文库数据</title>
    <link href="https://hyacinth.fit/archives/62201.html"/>
    <id>https://hyacinth.fit/archives/62201.html</id>
    <published>2021-06-05T02:20:35.000Z</published>
    <updated>2021-06-10T12:23:19.394Z</updated>
    
    <content type="html"><![CDATA[<p>使用 python3 抓取百度文库特点文章数据，只对可查看的内容有效。通过分析查找传输内容数据的 js 链接，而后请求即可</p><img data-src="https://i.loli.net/2021/06/07/igN6U5TuVYI7wrC.png"  /><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>经过排查，发现数据所在文件位置</p><p><img data-src="https://i.loli.net/2021/06/05/BRLcKDuITevVJSf.png"></p><p>查看其 url 请求，发现有个 <code>authorization</code></p><p><img data-src="https://i.loli.net/2021/06/05/geCMP8j7KS3wxzH.png"></p><p>开启 Ctrl F 大法，找到了 url 请求的出处，用正则把其中的链接给提前出来就可以取到数据了</p><p><img data-src="https://i.loli.net/2021/06/05/FVmD7PR8nYULI6t.png"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WenKu</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.get_url()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_url</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&quot;https://wenku.baidu.com/view/b35a73c5ee3a87c24028915f804d2b160b4e86c6&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;wenku.baidu.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.get(url=url,headers=headers)</span><br><span class="line">        html = etree.HTML(response.text)</span><br><span class="line">        script_content = html.xpath(<span class="string">&#x27;//script[2]/text()&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">        recompile = re.<span class="built_in">compile</span>(<span class="string">&#x27;.*?var pageData = (.*?);.*?window.pageData = pageData;.*?&#x27;</span>,re.S)</span><br><span class="line">        page_data = json.loads(recompile.findall(script_content)[<span class="number">0</span>])</span><br><span class="line">        js = json.loads(page_data[<span class="string">&#x27;readerInfo2019&#x27;</span>][<span class="string">&#x27;htmlUrls&#x27;</span>])[<span class="string">&#x27;json&#x27;</span>]</span><br><span class="line">        <span class="keyword">for</span> page_load_urls <span class="keyword">in</span> js:</span><br><span class="line">            page_load_url = page_load_urls[<span class="string">&#x27;pageLoadUrl&#x27;</span>]</span><br><span class="line">            self.get_data(page_load_url)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_data</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;wkbjcloudbos.bdimg.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.get(url=url,headers=headers)</span><br><span class="line">        print(response.content.decode(<span class="string">&#x27;unicode_escape&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    WenKu()</span><br></pre></td></tr></table></figure><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img data-src="https://i.loli.net/2021/06/05/HzgZkCqL15JyNTj.png"></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 python3 抓取百度文库特点文章数据，只对可查看的内容有效。通过分析查找传输内容数据的 js 链接，而后请求即可&lt;/p&gt;
&lt;img src=&quot;https://i.loli.net/2021/06/07/igN6U5TuVYI7wrC.png&quot;  /&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hyacinth.fit/categories/Python/"/>
    
    
    <category term="爬虫" scheme="https://hyacinth.fit/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python 登录土巴兔，解决 RSA 加密</title>
    <link href="https://hyacinth.fit/archives/6310.html"/>
    <id>https://hyacinth.fit/archives/6310.html</id>
    <published>2021-06-03T01:38:50.000Z</published>
    <updated>2021-06-07T11:53:42.707Z</updated>
    
    <content type="html"><![CDATA[<p>使用 python3 模拟登录土巴兔装修网，主要解决 RSA 加密问题</p><p><img data-src="https://i.loli.net/2021/06/07/b6g9NspVKuXcPd8.png"></p><span id="more"></span><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>先进行一次登录，在开发者工具里搜索关键词</p><p><img data-src="https://i.loli.net/2021/06/05/NZC3DYEXJbIwtFc.png"></p><p>可以看到账号和密码都经过了加密处理，接下来就继续找加密函数，可以看到名为 loginAndReg.js 的文件，点进去一看很明显是 <code>jQuery </code>的语法，其中对数据进行了 RSA 算法加密</p><p><img data-src="https://i.loli.net/2021/06/05/u4JBDqfwbyI96Ev.png"></p><p>开始常规操作，下断点，一步步找到关键的 <code>public_key</code></p><p><img data-src="https://i.loli.net/2021/06/05/dAKpw9cBjFrRqHT.png"></p><p><img data-src="https://i.loli.net/2021/06/05/P9pxErM6cBwYnoU.png"></p><p><img data-src="https://i.loli.net/2021/06/05/DzshSRTyMqLUwvV.png"></p><p><img data-src="https://i.loli.net/2021/06/05/XE4OMspPUx37NZI.png"></p><p><code>public_key</code> 找到了，即 RSA 算法的公钥，关键的解决掉了，接下来就是一个验证码的处理过程，不细展开了</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> lxml <span class="keyword">import</span> etree</span><br><span class="line"><span class="keyword">import</span> rsa</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> pytesseract</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">To8To</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,username,password</span>):</span></span><br><span class="line">        self.session = requests.Session()</span><br><span class="line">        self.username = self.RSAString(username)</span><br><span class="line">        self.password = self.RSAString(password)</span><br><span class="line">        self.login()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># RSA算法并进行urlencode编码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">RSAString</span>(<span class="params">self,text</span>):</span></span><br><span class="line">        publickeystr = <span class="string">&quot;&quot;&quot;-----BEGIN PUBLIC KEY-----</span></span><br><span class="line"><span class="string">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDhNhuAr4UjFv+cj99PbAQWWx9H</span></span><br><span class="line"><span class="string">X+3jSRThJqJdXkWUMFMTRay8EYRtPFIiwiOUU4gCh4ePMxiuZJWUBHe1waOkXEFc</span></span><br><span class="line"><span class="string">Kg17luhVqECsO+EOLhxa3yHoXA5HcSKlG85hNV3G4uQCr+C8SOE0vCGTnMdnEGmU</span></span><br><span class="line"><span class="string">nG1AGGe44YKy6XR4VwIDAQAB</span></span><br><span class="line"><span class="string">-----END PUBLIC KEY-----&quot;&quot;&quot;</span></span><br><span class="line">        result = rsa.encrypt(text.encode(<span class="string">&#x27;utf-8&#x27;</span>),rsa.PublicKey.load_pkcs1_openssl_pem(publickeystr.encode(<span class="string">&#x27;utf-8&#x27;</span>)))</span><br><span class="line">        <span class="keyword">return</span> requests.utils.quote(base64.b64encode(result).decode())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 登陆土巴兔</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = <span class="string">&quot;https://www.to8to.com/new_login.php&quot;</span></span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;Accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Accept-Language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Cache-Control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Connection&#x27;</span>: <span class="string">&#x27;keep-alive&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Length&#x27;</span>: <span class="string">&#x27;439&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/x-www-form-urlencoded&#x27;</span>,</span><br><span class="line">            <span class="comment"># &#x27;Cookie&#x27;: &#x27;uid=CgoLDl+fxedYQcbnA9+SAg==; sourcepath=b1; to8to_landtime=1604306408; to8to_keywordlist=,,,,,,,,,土巴兔; tracker2019session=%7B%22session%22%3A%22175881d12a348b-054bffcd976ceb-c781f38-2073600-175881d12a4664%22%7D; tracker2019jssdkcross=%7B%22distinct_id%22%3A%22175881d12a823b-0b99c9a8d8c678-c781f38-2073600-175881d12a93b1%22%7D; to8to_tcode=sz; to8to_tname=%E6%B7%B1%E5%9C%B3; to8to_townid=1130; Hm_lvt_dbdd94468cf0ef471455c47f380f58d2=1604306408; to8tocookieid=16ca84d48a125ffcf2b9c3901c5edc0f853582; to8tosessionid=s_ab26dc179eaefefdea5b3b108cbf2bf1; to8to_cook=OkOcClPzRWV8ZFJlCIF4Ag==; tender_popup_flag=true; layer-popup=true; to8to_landpage=http%3A//sz.to8to.com/; to8to_sourcepage=; to8to_nowpage=http%253A%252F%252Fsz.to8to.com%252F; PHPSESSID=bo9224bbpec2hms9upgn240105; agreementRead=true; Hm_lpvt_dbdd94468cf0ef471455c47f380f58d2=1604307019; act=freshen&#x27;,</span></span><br><span class="line">            <span class="string">&#x27;Host&#x27;</span>: <span class="string">&#x27;www.to8to.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Origin&#x27;</span>: <span class="string">&#x27;https://www.to8to.com&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Referer&#x27;</span>: <span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-Site&#x27;</span>: <span class="string">&#x27;same-origin&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Sec-Fetch-User&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        data = &#123;</span><br><span class="line">            <span class="string">&#x27;referer&#x27;</span>: <span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;val&#x27;</span>: self.username,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span>: self.password</span><br><span class="line">        &#125;</span><br><span class="line">        response = self.session.post(url=url,headers=headers,data=data)</span><br><span class="line">        print(response.text)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;用户名不存在&quot;</span> <span class="keyword">in</span> response.text <span class="keyword">or</span> <span class="string">&quot;登录失败次数过多，请30分钟后再试！&quot;</span> <span class="keyword">in</span> response.text:</span><br><span class="line">            html = etree.HTML(response.text)</span><br><span class="line">            yzm_url = <span class="string">&#x27;https:&#x27;</span> + html.xpath(<span class="string">&#x27;//img[@id=&quot;passport&quot;]/@src&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">            data[<span class="string">&#x27;yzm&#x27;</span>] = self.img_to_text(yzm_url)</span><br><span class="line">            response = self.session.post(url=url, headers=headers, data=data)</span><br><span class="line">            print(response.text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 验证码识别</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">img_to_text</span>(<span class="params">self,url</span>):</span></span><br><span class="line">        parses = requests.utils.urlparse(url)</span><br><span class="line">        path = parses.path + parses.params + <span class="string">&#x27;?&#x27;</span> + parses.query</span><br><span class="line">        headers = &#123;</span><br><span class="line">            <span class="string">&#x27;referrer&#x27;</span>:<span class="string">&#x27;https://www.to8to.com/new_login.php&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;method&#x27;</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;path&#x27;</span>: path,</span><br><span class="line">            <span class="string">&#x27;scheme&#x27;</span>: <span class="string">&#x27;https&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept&#x27;</span>: <span class="string">&#x27;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept-encoding&#x27;</span>: <span class="string">&#x27;gzip, deflate, br&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;accept-language&#x27;</span>: <span class="string">&#x27;zh-CN,zh;q=0.9&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;cache-control&#x27;</span>: <span class="string">&#x27;max-age=0&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-dest&#x27;</span>: <span class="string">&#x27;document&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-mode&#x27;</span>: <span class="string">&#x27;navigate&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-site&#x27;</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;sec-fetch-user&#x27;</span>: <span class="string">&#x27;?1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;upgrade-insecure-requests&#x27;</span>: <span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.75 Safari/537.36&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">        response = requests.get(url=url,headers=headers)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;yzm.png&#x27;</span>,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(response.content)</span><br><span class="line">        yzm = Image.<span class="built_in">open</span>(<span class="string">&#x27;yzm.png&#x27;</span>)</span><br><span class="line">        yzm = yzm.convert(<span class="string">&#x27;L&#x27;</span>)</span><br><span class="line">        threshold = <span class="number">127</span></span><br><span class="line">        table = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            <span class="keyword">if</span> i &lt; threshold:</span><br><span class="line">                table.append(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                table.append(<span class="number">1</span>)</span><br><span class="line">        yzm.point(table, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> pytesseract.image_to_string(yzm)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    To8To(<span class="string">&#x27;账号&#x27;</span>,<span class="string">&#x27;密码&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h3><p><img data-src="https://i.loli.net/2021/06/05/GCSr5vm9MTwgjpt.png"></p><h2 id="声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。"><a href="#声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。" class="headerlink" title="声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。"></a>声明：本文仅供学习交流使用，请勿用于商业用途，违者后果自负。</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用 python3 模拟登录土巴兔装修网，主要解决 RSA 加密问题&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/06/07/b6g9NspVKuXcPd8.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Python" scheme="https://hyacinth.fit/categories/Python/"/>
    
    
    <category term="爬虫" scheme="https://hyacinth.fit/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>谁动了我的奶酪</title>
    <link href="https://hyacinth.fit/archives/43828.html"/>
    <id>https://hyacinth.fit/archives/43828.html</id>
    <published>2021-03-11T06:41:51.000Z</published>
    <updated>2021-06-07T11:54:28.112Z</updated>
    
    <content type="html"><![CDATA[<p>《谁动了我的奶酪》（Who　Moved　My　Cheese?），生动的阐述了“变是唯一的不变”这一生活真谛，据说已经成为全世界最畅销的书。或许每一个人看完的感受都不一样，但千万不要说这个道理我懂，如果那样就说明你依然惧怕改变自己。</p><span id="more"></span><p><em>作者：（美）约翰逊</em> </p><h3 id="内容提要"><a href="#内容提要" class="headerlink" title="内容提要"></a>内容提要</h3><p>　　《谁动了我的奶酪？》是个简单的寓言故事，内容充满了人生中有关变化寓意深长的真理。这是个有趣且能启蒙智慧的故事，内容是在描绘四个住在“迷宫”里的人物，他们竭尽所能地在寻找能滋养他们身心、使他们快乐的“奶酪”的过程。 这四个小人物中，有两只是名叫“嗅嗅”和“匆匆”的老鼠；其他两位则是身体大小和老鼠差不多的小人，名叫“唧唧”和“哼哼”，而且这两个小人的外型与行为和现今的人类差不多。 这里所谓的“奶酪”是一种比喻，它可以被当成我们生命中最想得到的东西。它可能是一份工作、人际关系、金钱、财产、健康、心灵的宁静。 书中所谓的“迷宫”，代表的是一个你花费时间与精力追寻你所欲求的东西的地方，它可以是你所服务的机构或你所居住的社区。 在故事里，这些人物面临突如其来的变化。最后，他们之中有一个成功地对这些变化做出适当的应变，并在迷宫的墙上写下他改变自己的心路历程及从中所得到的经验。 当你看到那些墙上的标语时，你就能自己找出处理变化的方法，了解了这些方法，你就不会感到太多压力，并且能够在生活中或工作中得到更多的成就感（不管你怎么定义这些成就感和压力）。 这本书适合任何的年龄层，而且阅读这故事花费你不到一小时的时间，但其中独特的真知灼见却能对你产生一辈子的影响力和帮助。</p><hr><blockquote><p>再完美的计划也时常遭遇不测<br>生活并不是笔直通畅的走廊，<br>让我们轻松自在地在其中旅行，<br>生活是一座迷宫，<br>我们必须从中找到自己的出路，<br>我们时常会陷入迷茫，<br>在死胡同中搜寻。<br>但如果我们始终深信不疑，<br>有扇门就会向我们打开，<br>它也许不是我们曾经想到的那一扇门，<br>但我们最终将会发现，<br>它是一扇有益之门。<br>…….. </p></blockquote><p>故事中虚构的四个角色：老鼠嗅嗅和匆匆，小矮人哼哼和唧唧，用来代表我们的不同方面，即我们简单的一面和复杂的一面。</p><p>我们每个人都具有这些不同的方面，不论我们的年龄、性别、种族和国籍如何。</p><p>有时我们的行为象：嗅嗅，他能够及早嗅出变化的气息；或者像：匆匆，他能够迅速行动；或者像：哼哼，他因为害怕改变而否认和拒绝变化，这会使事情变得更糟，或者像：唧唧，当他看到变化会使事情变得更好时，能够及时地调整自己去适应变化!</p><p>不管我们选择哪一面，我们都有共同的方面，那就是：</p><p>需要在迷宫中找到我们自己的道路，帮助我们在变化的时代获得成功。 </p><hr><h3 id="故事背后的故事"><a href="#故事背后的故事" class="headerlink" title="故事背后的故事"></a>故事背后的故事</h3><p>— <em>肯尼思·布兰查德博士</em></p><p>　　几年前，斯宾塞·约翰逊和我一起合著《一分钟经理人》的时候，给我讲了一个精彩的故事—-“奶酪的故事”。自从我听到这个寓意深长的故事以后，我就一直盼望着他能把这个故事写成书，使我们大家都能读到它，一起分享书中的带给我们的快乐和教益，因为从那时起，我就一直在回味这个绝妙的故事，惊叹于它带给我的启迪。</p><p>　　现在，我怀着激动的心情向大家介绍这本《谁动了我的奶酪》，并给各位讲述有关这个故事背后的故事。</p><p>　　《谁动了我的奶酪》讲的是一个关于“变化”的故事。故事发生在一个迷宫中，有四个可爱的小生灵在迷宫中寻找他们的奶酪。故事里的“奶酪”是对我们在现实生活中所追求目标的一种比喻，它可以是一份工作，一种人际关系，可以是金钱，一幢豪宅，还可以是自由、健康、社会的认可和老板的赏识。它只是一种精神上的宁静，甚至还可以只是一项运动，如马术、高尔夫球等等。 我们每个人的内心都有自己想要的“奶酪”，我们追寻它，想要得到它，因为我们相信，它会带给我们幸福和快乐。而一旦我们得到了自己梦寐以求的奶酪，又常常会对它产生依赖心理，甚至成为的附庸；这时如果我们忽然失去了它，或者它被人拿走了，我们将会因此而受到极大的伤害。 故事里的“迷宫”代表着你花时间寻求着的东西所在的地方，它可以是你效力的机构，你生活的社区，亦或是你生活中的某种人际关系。</p><p>　　我到世界各地演讲时就时常讲到这个各位即将在本书中读到的“奶酪的故事”，并且我常常听到人们在听完这个故事以后所发出的由衷的感叹，感叹这个故事带给他们的影响与改变。</p><p>　　信不信由你，这个小小的“奶酪的故事”已经获得了普遍的赞誉，它帮助了许许多多的人，因为它挽救了他们的事业、婚姻以及他们的生活!</p><p>　　这里我经大家讲一个真实的故事，主人翁就是深孚众望的NBC电视节目主持人查理·琼斯。他就是因为这个“奶酪的故事”，而使自己的事业生涯获得了转机。虽然电视节目主持人的职业很特殊，但是查理从故事中所学到的道理都适合于任何一种职业特性，并且人人都可以学习和掌握。</p><p>　　以下就是发生在查理·琼斯身上的故事。</p><p>　　查理早期所从的主要工作，是报道奥运会的田径项目，他在这项工作上很努力而且一直都干得非常出色。但是，突然有一天老板告诉他，下一届奥运会将派他去报道游泳和跳水项目。听到这个消息，查理既吃惊又难过。</p><p>　　因为他对游泳和跳水这两个项目完全不熟悉，这样的安排使他有一种挫折感，觉得自己不被重用和赏识。他说当时他感到这样的安排对他来说太不公平了，他为此而愤愤不平。并且这种愤怒的情绪几乎影响到了他所做的每一件事情，他的生活开始变得一团糟。 就在这时，他听到了这个故事—-“谁动了我的奶酪”。</p><p>　　听完故事后，他觉得自己以前的态度和行为十分可笑并迅速采取行动，进行调整。从此，他的工作和行为大大地改善了。因为他已经明白，老板只是拿走了他的奶酪而已，而他所应该做的就是调整自己，适应变化。于是他很快调整好自己的状态，以便适应新的工作，并开始下功夫去熟悉、了解游泳和跳水项目。在开展新工作的过程中，他惊奇地发现，做新的事情竟然使他感觉又焕发了青春。 不久，老板发现查理改变了工作态度，并且重新焕发出了新的活力，于是，给他分派了更多的新的有挑战的工作。从此查理走上了不断成功的道路，并从中享受到了前所未有的喜悦。后来，他被推选为“职业足球名人堂”最佳播音员之一。</p><p>　　我听到很多人表示，这个故事对他们的职业生涯和情感生活产生了巨大的冲击和震憾，而查理·琼斯的故事只是真实生活中这许许多多例子中的一个。</p><p>　　我是如此地相信“谁动了我的奶酪”这个故事所具有的影响力和震撼力，以致于我把这个故事成书之前的一个版本，送给每一位同我们公司有合作的人(大约二百多人)。我为什么这样做呢？</p><p>　　因为，一个公司的经营，不能只停留在求生存的阶段，而必须始终保持一种竞争的状态。我们布兰查德培训公司就是在不断地改变着，有人不断地拿走我们的“奶酪”。过去，传统的公司喜欢忠诚刻板的员工；而今天，我们更需要的是迅捷灵活的人而不是那种习惯于“按部就班”工作的雇员。</p><p>　　我们都知道，工作与生活就像不断翻滚的浪花，各种变化都在时时发生。生活在其中，的确使人感到紧张不安，除非有一种办法能使我们关注到这些变化，并且能够从中得到启迪。有一条找到这种办法的途径，那就是走进“奶酪的故事”。</p><p>　　当人们听我讲起这个故事后，就纷纷开始去读《谁动了我的奶酪》。而在阅读过程中，几乎每个人都感觉到这个故事让人有一种释放压力并开始放松的神奇作用。各个部门的人一个又一个地跑来感谢我向他们介绍了这本书，并且告诉我这本书对他们的帮助是多么巨大，使得他们能够从不同的角度看待公司正面临的种种变化。</p><p>　　请相信我，这则简短的寓言只需花费你不多的时间，但它带给你的影响将是深远的。</p><p>　　本书包括三个部分。</p><p>　　第一部分，“同学聚会”—-讲述一群过去的同窗在一次聚会上讨论如何应对生活中的种种变化。</p><p>　　第二部分是全书的核心—-“谁动了我的奶酪”的故事。</p><p>　　在故事里，你会发现，当面对变化时两个老鼠做得比两个小矮人要好，因为他们总是把事情简单化；而当两个小矮人所具有的复杂的脑筋和人类的情感，却总是把事情变得复杂化。这并不是说老鼠比人更聪明，我们都知道人类更具智慧。但换个角度想，人类那些过于复杂的智慧和情感有时又何尝不是前进道路上的阻碍呢？</p><p>　　当你观察故事中四个角色的行为时，你会发现，其实老鼠和小矮人代表我们自身的不同方面—-简单的一面和复杂的一面。当事物发生变化时，或许简单行事会给我们带来许多的便利和益处。</p><p>　　本书的第三部分，“讨论”—-是那些同窗好友们围绕这个故事展开的讨论，他们讨论这个故事的意味，以及如何把这个故事带给人们的启迪运用到生活与工作中去。</p><p>　　有些读过成书之前的手稿的读者读完故事本身后就停下来，不再继续阅读关于这个故事的讨论。另外一些人则更乐于阅读故事后面的“讨论”，因为他们认为从中可以受到启发，可以思考如何将从故事中的东西运用到他们的实际生活中去。</p><p>　　无论怎样，我都真诚地希望各位像我一样，在每次阅读这个故事的时候，都能从中领悟到一些新的、有用的东西；希望它能帮助你妥善地应对各种变化，不论你的成功目标是什么，它都能助你走向成功。</p><p>　　我希望你们能欢欣于你们从故事中所发现的道理，并能享受到这一发现的乐趣。祝你们一切顺利。 请记住一句话：<strong>随着‘奶酪’的变化而变化，并且享受变化</strong>。</p><hr><h3 id="芝加哥的同学聚会"><a href="#芝加哥的同学聚会" class="headerlink" title="芝加哥的同学聚会"></a>芝加哥的同学聚会</h3><p>　　芝加哥一个阳光明媚的星期天，许多过去在学校曾是好朋友的同班同学聚在一起搞午餐会。前一天晚上，他们刚参加完全体高中同学的聚会。在一阵打闹嬉笑和丰盛的午餐后，他们坐下来开始了饶有兴致的交谈，希望彼此多了解一些后的生活经历。</p><p>　　安杰拉曾是班上最受欢迎的人之一，她第一个发表感慨：“生活真和是跟我们做学生时想象的完全不一样，变化太多了。”</p><p>　　“的确如此!”内森附和道。内森正如大家所预料的那样，毕业后就进入了他的家族企业。这家企业的经营模式经年未变，在当地人的记忆中，那可是一家历史悠久的老字号了。因此，当内森若有所思地附和着安杰拉，并发出如此感叹时，大家都感到有些吃惊。 内森好像并未注意到大家的诧异，表情忧郁地接着说：“你们是否注意到，当周围的事情已经发生变化时，我们都不想对自己有所改变。”</p><p>　　卡洛斯接着说道：“我们拒绝改变，是因为我们害怕改变。”</p><p>　　杰西拉接过他的话：“噢，卡洛斯，你可是学校的足球队长，我们心目中的英雄，我从没想过还有什么东西可以让你害怕的。”</p><p>　　大家都笑起来。他们意识到，尽管大家毕业后都在各自不同的方面发展—-从在家工作到在外经营管理公司—-但好像都有类似的感觉—-害怕改变。</p><p>　　这些年来，每个人都试图对发生在生活中的各种意想不到的变化。但大家都承认，他们找不到一种很好的应对方法。</p><p>　　这时，迈克尔发话了：“我过去也一直害怕改变，直到有一天，我们的生意出现了一个重大的变故，但我们公司所有的人都不知道怎样去应付，由于我们没有及时做出调整，使我们几乎丢掉了全部的生意。”</p><p>　　“后来，”迈克尔继续讲道：“我听到了一个故事，这个故事使一切都改变了。”</p><p>　　“此话怎讲？”内森问道。</p><p>　　“喔，因为这个故事改变了我害怕改变的个性以及我对变化的看法—-从害怕失去某些东西到期待获得某些东西—-它教会我如何去做。从那以后，我的一切都迅速地改善了—-无论工作还是生活。”</p><p>　　“是什么故事这么神奇？”好几个人异口同声地问道。</p><p>　　“一开始，我被这个故事显而易见的简单给惹恼了，它就像我们小时候听腻了的那些寓言故事一样。”</p><p>　　“后来我发现，其实我是被自己惹恼了，我为自己不懂得这样简单明白的道理，在事情发生变化时不能采取有效的举动而感到恼怒。”</p><p>　　“再后来，我把这个故事告诉我们公司里的其他人，其他人又讲给其他人听。很快，公司里的业务有了明显的改进，因为我们大家都能及时地做出很好的调整以随时应对变化。与我的感受一样，许多人都说，这个故事使他们的个人生活大受裨益。”</p><p>　　“当然，也有人说他们从中没有得到什么，他们或者是知道这样的教训而且已经领教多次了。或者，更普遍的是，他们觉得自己已经懂得够多，不需要再学习什么了。他们甚至假装看不到如此多的人正在从中受益。”</p><p>　　“我的一位有些呆板的高级主管就说，读这个故事只是浪费时间。然而大家都取笑他，把他比做故事中的一个角色—-从不学习新的东西而且从不愿意改变。“</p><p>　　安杰拉有些迫不及待：“别卖关子了，这究竟是一个什么样的故事？”</p><p>　　“故事的名字叫作‘谁动了我的奶酪’。”</p><p>　　大家都哄笑起来。卡洛斯说：“我想仅凭这个名字，我就己经喜欢上这个故事了。你能讲给我们听听吗？或许我们也会从中有所收获。”</p><p>　　“当然，”迈克尔答道：“我非常愿意把这个故事讲给你们听。它并不长。”于是，他开始给大家讲述这个故事。</p><hr><h3 id="“谁动了我的奶酪-”的故事"><a href="#“谁动了我的奶酪-”的故事" class="headerlink" title="“谁动了我的奶酪?”的故事"></a>“谁动了我的奶酪?”的故事</h3><p>　　从前，在一个遥远的地方，住着四个小家伙。为了填饱肚子和享受乐趣，他们每天在不远处的一座奇妙的迷宫里跑来跑去，在哪里寻找一种叫做“奶酪”的黄橙橙、香喷喷的食物。</p><p>　　有两个小家伙是老鼠，一个叫“嗅嗅”，另一个叫“匆匆”。另外两个家伙是小矮人，和老鼠一样大小，但和人一个模样，而且他们的行为也和我们今天的人类差不多。他俩的名字，一个叫“哼哼”，另一个叫“唧唧”。</p><p>　　由于他们四个实在太小了，他们在干什么当然不太会引起旁人的注意。但如果你凑近去仔细观察，你会发现许多令人惊奇不已的事情！ 两个小老鼠和两个小矮人每天都在迷宫中度过，在其中寻找他们各自喜欢的奶酪。嗅嗅、匆匆的大脑和其他啮齿类动物的差不多一样简单，但他们有很好的直觉。和别的老鼠一样，他们喜欢的是那种适合啃咬的、硬一点的奶酪。</p><p>　　而那两个小矮人，哼哼和唧唧，则靠脑袋行事，他们的脑袋里装满了各种各样的信念和情感。他们要找的是一种带字母“C”的那奶酪。他们相信，这样的奶酪会给他们带来幸福。使他们成功。</p><p>　　尽管小老鼠和小矮人的目标各不相同，但他们做的事情是差不多的。每天早上，他们会各自穿上运动服和慢跑鞋，离开他们的小房子，跑进迷宫寻找他们各自钟爱的奶酪。</p><p>　　迷宫中有许多曲折的走廊和好像蜂窝的房间，其中的一些房间里藏着美味的奶酪，但更多的地方是黑暗的角落和隐藏的死胡同，任何人走进去都很容易迷路。</p><p>　　同时，这座迷宫还有一种神奇的力量，对那些找到出路的人，它能使他们享受到美好的生活。</p><p>　　两个小老鼠，嗅嗅和匆匆，总是运用简单低效的反复尝试的办法找奶酪。他们跑进一条走廊，如果走廊的房间都是空的，他们就返回来，再去另一条走廊搜寻。没有奶酪的走廊都会记住。就这样，很快地他们从一个地方找到另一个地方。嗅嗅可以用他那了不起的鼻子嗅出奶酪大致的方向，匆匆则跑在前面开路。然而迷宫太大太复杂，如你所料，他们经常会迷路，离开正道走错了方向，有时甚至还会撞倒墙上。</p><p>　　两个小矮人，哼哼和唧唧，则运用他们思考的能力，从过去的经验中学习。他们靠复杂的脑筋，搞出了一套复杂的寻找奶酪的方法。</p><p>　　哼哼和唧唧的方法比他们的老鼠朋友要高效，因此他们走进死胡同和碰壁的情况要比小老鼠们少得多。他们也为此而时常沾沾自喜很是得意，甚至有些看不起低智商的老鼠朋友。然而有时候，人类复杂的头脑所带来的复杂感情也会战胜他们的理性思维，使他们看问题的眼光变得暗淡起来。这也使得他们在迷宫里的生活更加复杂化，也更具有挑战性了。</p><p>　　但不管怎样，这四个家伙嗅嗅和匆匆，哼哼和唧唧，都以他们各自不同的方式不懈的追寻着他们想要得到的东西。最后，终于有一天，在某个走廊的尽头，在奶酪C站，他们都找到了自己想要的奶酪。</p><p>　　这里真是一个天堂，四个小家伙被眼前的情景惊呆了，无数各种各样的奶酪堆积如山，闪着诱人的光亮。四个小家伙呆了半晌，然后就疯了般地冲进奶酪堆，开始狂欢。 从那以后，这四个家伙，小老鼠和小矮人，每天早上穿上他们的跑步装备后便毫不犹豫地直奔奶酪C站。不久，他们都建立了熟悉的路线，并形成了各自的生活习惯。</p><p>　　嗅嗅和匆匆仍旧每天都起得很早，然后沿着相同的路线跑进迷宫中。</p><p>　　当老鼠们到达目的地后，他们脱下自己的跑鞋，有条不紊地将两只鞋系在一起，挂在脖子上;以便需要的时候很快穿上。然后他们才开始尽情地享用奶酪。</p><p>　　在开始一段时间里，哼哼和唧唧也是如此行事，每天早上赶到奶酪C站，按部就班的把鞋子挂在脖子上，享用在那里等着他们的美味佳肴。</p><p>　　然而不久以后，小矮人们改变了他们的常规。</p><p>　　哼哼和唧唧每天起得比老鼠们晚一些，懒懒地穿好运动服，然后信步走到奶酪C站。不管怎样，反正已经找到了奶酪。</p><p>　　他们从没想过，奶酪是从哪里来的，是谁把他们放在那里的。他们只是理所当然地认为，奶酪总是会在 那里的。</p><p>　　每天，哼哼和唧唧到奶酪C站以后，就像回到自己的家一样，舒服的呆在哪里。他们脱下运动衣，把它们挂起来，甩掉脚上的鞋子，换上拖鞋。他们找到了奶酪，感觉实在是太惬意了。</p><p>　　“真是太好了！”哼哼说：“这里有这么多奶酪，足够我们享用一辈子了。”小矮人们充满了幸福和成功的感觉，觉得从此可以无忧无虑了。</p><p>　　不久，哼哼和唧唧更理所当然地认定，他们在奶酪C站发现的奶酪就是“他们自己的”奶酪了。这里的奶酪库存是如此的丰富，于是他们决定把家搬到各靠近奶酪C站的地方，还在周围一带开展了他们的社交活动。 </p><p>　　为了使这里更像家的感觉，哼哼和唧唧把墙壁装饰了一通，还在墙上写了一些格言，并精心地画上了一些非常可口的奶酪的图案。他们看着这些图画和格言，会心地笑了，其中一幅图画的内容是：</p><p><strong>拥有奶酪，就拥有幸福。</strong></p><p>　　有时，他们会带朋友来参观他们在奶酪C站里成堆的奶酪，自豪地指着这些奶酪说：“多么美妙可口的奶酪呀，不是吗？”有时，他们还会与朋友们一起分享这些奶酪，而有时则是单独享用。</p><p>　　“我们应该拥有这些奶酪，”哼哼说，“为了找到它们，我们可是付出了长期而艰苦的努力的，我们当然有资格拥有它们。”他一边说着一边拿起一块鲜美的奶酪放进嘴里，享用起来，脸上流露出幸福的光彩。</p><p>　　然后，就像往常一样，哼哼享受完奶酪便睡着了，梦里还路除满足而惬意的笑容。</p><p>　　每天晚上，小矮人们在美美地饱餐了奶酪后，就摇摇摆摆地走回家，第二天早上他们又会信心十足地走进奶酪C站，去享用更多的奶酪。</p><p>　　这样的境况维持了相当长的一段时间。</p><p>　　逐渐地，哼哼和唧唧的自信开始膨胀起来。面对成功，他们开始变得妄自尊大。在这种安逸的生活中，它们丝毫没有察觉到正在发生的变化。</p><p>　　随着时间的流逝，嗅嗅和匆匆日复一日地重复着他们的生活。每天早早地赶到奶酪C站，四处闻一闻、抓一抓，看看这区域和前一天有什么不一样。等到确定没有任何异常后他们才会坐下来细细品味奶酪，好好享受一番。</p><p>　　一天早上，当嗅嗅和匆匆到达奶酪C站时，发现这里已经没有奶酪了。<br>　　对此，他们并不感到吃惊，因为他们早已察觉到，最近好像有一些奇异的事情正在奶酪C站里发生，因为这里的奶酪已经越来越小，并且一天比一天少了。他们对这种不可避免的情况早有心理准备，而且直觉地知道该怎么办。</p><p>　　他们相互对望了一眼，毫不犹豫地取下挂在脖子上的跑鞋，穿上脚并系好鞋带。</p><p>　　两只小老鼠对此并没有做什么全面细致的分析，事实上，也没有足够复杂的脑细胞可以支持他们进行这么复杂的思维。</p><p>　　对老鼠来说，问题和答案都是一样的简单。奶酪C站的情况发生了变化，所以，他们也决定随之而变化。</p><p>　　他们同时望向迷宫深处。嗅嗅扬起他的鼻子闻了闻，朝匆匆点点头，匆匆立刻拔腿跑向迷宫的深处，嗅嗅则紧跟其后。</p><p>　　他们开始迅速行动，去别的地方寻找新的奶酪，甚至连头都没有回一下。</p><p>　　同一天的晚些时候，哼哼和唧唧也像往常一样溜溜达达地来到奶酪Ｃ站，一路上哼着小曲。他们过去一直没有察觉到这里每天都在发生的细小变化，而想当然地以为他们地奶酪还在那里。</p><p>　　面对新的情况，他们毫无准备。</p><p>　　“怎么！竟然没有奶酪？”哼哼大叫道，然后他开始不停地大喊大叫，“没有奶酪？怎么可能没有奶酪？”好像他叫喊地声音足够大的话，就会谁把奶酪送回来似的。</p><p>　　“谁动了我的奶酪？”他声嘶力竭地呐喊着。</p><p>　　最后，他把手放在屁股上，脸憋得通红，用他最大的嗓门叫道：“这不公平！”</p><p>　　唧唧则站在那里，一个劲的摇头，不相信这里已经发生的变化。对此，他同样没有任何心里准备，他满以为在这里照旧可以找到奶酪。他长时间地站在那里，久久不能动弹，完全被这个意外给惊呆了。</p><p>　　哼哼还在疯狂地叫嚷着什么，但唧唧不想听，他不想面对眼前的现实，他拼命告诉自己，这只是一个噩梦，他只想回避这一切。</p><p>　　他们的行为并不可取，而且也于事无补，但我们总还是能够理解的。</p><p>　　要知道找到奶酪并不是一件容易的事情。更何况，对这两个小矮人来说，奶酪绝不仅仅只是一样填饱肚子的东西，它意味着他们悠闲的生活、意味着他们的荣誉、意味着他们的社交关系以及更多重要的事情。</p><p>　　对他们来说，找到奶酪是获得幸福的唯一途径。根据不同的偏爱，他们对奶酪的意义有各自不同的看法。对有些人而言，奶酪代表的是一种物质上的享受；而对另一些人来说，奶酪则意味着健康的生活，或者是一种安宁富足的精神世界。</p><p>　　对唧唧来说，奶酪意味着安定，意味着某一天能够拥有一个可爱的家庭，生活在名人社区的一座舒适的别墅里。</p><p>　　对哼哼来说，拥有奶酪可以使他成为大人物，可以领导很多的人，而且可以在卡米伯特山顶上拥有一座华丽的宫殿。</p><p>　　由于奶酪对他们实在太重要了，所以这两个小矮人花了很长时间试图决定该怎么办。但他们所能够想到的，只是在奶酪Ｃ站里寻找，看看奶酪是否真的不存在了。</p><p>　　当嗅嗅和匆匆已经迅速行动的时候，哼哼和唧唧还在那里不停地哼哼唧唧、犹豫不决。</p><p>　　他们情绪激动地大声叫骂这世界的不公平，用尽一切恶毒的语言去诅咒那个搬走了他们奶酪的黑心贼。然后唧唧开始变的消沉起来，没有了奶酪，明天会怎样？他对未来的计划完全都建立在这些奶酪的基础上面的啊！</p><p>　　这两个小矮人不能接受这一切。这一切怎么可能发生呢？没有任何人警告过他们，这是不对的，事情不应该是这个样子的，他们始终无法相信眼前的事实。</p><p>　　那天晚上，哼哼和唧唧饥肠辘辘、沮丧地回到家里。在离开之前，唧唧在墙上写下了一句话：</p><p><strong>奶酪对你越重要，你就越想抓住它。</strong></p><p>　　第二天，辗转难眠了一晚上的哼哼和唧唧早早地离开家又回到奶酪C站，不管怎样，他们抱着一线希望，他们不断地欺骗自己，假定昨天走错了地方，他们仍然希望找回他们的奶酪。奶酪站的位置没有变化，然而奶酪的的确确早已不复存在。两个小矮人顿时手足无措，不知道该怎么办。哼哼和唧唧只是站在那里，一动不动，就像两座毫无生气的雕像。</p><p>　　唧唧紧紧闭上眼睛，用手捂住自己的耳朵，他只想把一切都堵在外面。他不愿相信奶酪是逐渐变得越来越小的，他宁愿相信奶酪是突然之间被全部拿走的。</p><p>　　哼哼则把现在的情况分析了又分析，他用他复杂的大脑把他所有的信条都翻了个遍。“他们为什么要这样做？”他终究没能找到答案，“这里究竟发生了什么事情？” 终于，唧唧睁开了眼睛，朝周围看了看说：“顺便问一下，嗅嗅和匆匆现在在哪里？你是否觉得他们知道某些我们还不知道的事情？”</p><p>　　“那两个弱智，他们能知道些什么？”哼哼的语气中充满了不屑。</p><p>　　他继续说：“他们只是头脑简单的老鼠，他们只会对发生的事情做出简单的反应。而我们是机伶聪明的小矮人，我们比老鼠有头脑。我们应该能够推测出这里的情况。”</p><p>　　“我知道我们更聪明，”唧唧说，“但是，我们现在的行为好像并不怎么聪明。我们周围的情况已经发生了变化，哼哼，也许我们需要做出一些改变，去做点什么不同的事情。”</p><p>　　“我们为什么要改变？”哼哼问道，“我们是小矮人，我们是不一样的。这样的事情不应该发生在我们的身上。即使出现了这样的情况，我们至少也应该从中得到一些补偿。”</p><p>　　“为什么我们应该得到一些补偿呢？”唧唧问。</p><p>　　“因为我们有这样的权利。”哼哼宣称。</p><p>　　“有什么样的权利？”唧唧不明白。</p><p>　　“有拥有我们奶酪的权利。”</p><p>　　“为什么？”唧唧还是不明白。</p><p>　　“因为这个问题不是我们引起的，”哼哼说，“是某些别有用心的人制造了这个局面，而不是我们，所 以我坚持认为我们总应该从中得到些补偿。”</p><p>　　“也许我们应该停止这种无用的分析，”唧唧提议，“分析问题到此为止。在我们还没有被饿死之前，我们应该赶紧出发去找新的奶酪。”</p><p>　　“噢，不！”哼哼反对说，“我们快要找到问题的根源了，要知道，我们曾经拥有过那么多、那么好的奶酪啊！”</p><p>　　当哼哼和唧唧还在争执着试图决定该怎么办的时候，嗅嗅和匆匆已经在很顺利的做他们的事情了。他们进入了迷宫的更深处，走过一条又一条走廊，在每一个他们遇到的奶酪站里仔细寻找着奶酪。</p><p>　　除了倾尽全力地寻找新的奶酪，他们并不考虑任何别的事情。</p><p>　　有好一段时间，他们找得很辛苦却一无所获。直到他们走进迷宫中一个他们从未到过的地方：奶酪N站。</p><p>　　他们高兴得尖叫起来，他们终于发现了他们一直在寻找的东西：大量新鲜的奶酪。</p><p>　　他们简直不敢相信自己的眼睛，这是他们见过的最大的奶酪仓库。</p><p>　　而与此同时，哼哼和唧唧仍然呆在奶酪C站，对他们目前的处境进行揣摩。他们正在忍受着失去了奶酪的痛苦，挫折感、饥饿感和由此而来的愤怒紧紧围绕着他们，折磨着他们，他们甚至为陷入眼前的困境而相互指责。</p><p>　　唧唧仍然时时想起他的老鼠朋友，猜想他们现在是否已经找到了奶酪。他相信他们也许过得很困难。在迷宫中穿行，总会面临许多难以预料的事情。但他也知道，什么事情也得有不容易的一个阶段。</p><p>　　有时，唧唧会想出嗅嗅和匆匆已经找到了新的奶酪并正在享用他们的情景。他忽然有一种冲动，想到迷宫中冒险去寻找新的奶酪。在迷宫中探险，找到新的奶酪并尽情享用，这一切该是多么的美好啊！想到这里，他觉得仿佛自己已经尝到了新鲜奶酪的美味。</p><p>　　正在寻找和享用新的奶酪，这样的情景在唧唧的头脑中越来越清晰。他觉得自己越来越想离开奶酪C站，出发去寻找新的奶酪。</p><p>　　突然，他大声宣布道：“我们走吧！”</p><p>　　“不！”哼哼很快作出了反应：“我喜欢这里。我只熟悉这里，这里很好很舒服。再说，离开这里到外 面去是很危险的。”</p><p>　　“不会的，”唧唧说：“以前我们也曾经到过这个迷宫中的许多地方，我们还可以再去其他地方找找看。”</p><p>　　“我觉得自己已经有些老了，不能再做这种跑来跑去到处冒险的事了。”哼哼说：“而且，我也不想像个傻瓜似的，时常迷路。你觉得呢？” 听哼哼这么一说，失败的恐惧感又袭上了唧唧的心头，他的那点发现新奶酪的希望有逐渐消退了。</p><p>　　就这样，这两个小矮人继续作着以前每天所作的事。他们仍然每天都去奶酪C站，发现还是找不到奶酪，然后怀着忧虑和挫败的心情回到家里。</p><p>　　他们试图否认眼前发生的一切，开始失眠，力气一天比一天小，变得越来越烦躁易怒。</p><p>　　他们的家，也不再是美好舒适的地方。他们睡不上一个安稳觉，而且每晚的时光都伴着找不到奶酪的噩梦度过。</p><p>　　但他们仍然每天回到奶酪C站，仍然每天在那里等待。</p><p>　　哼哼说：“你知道，如果我们再努力一些，我们也许会发现事情并没有发生太大的变化。奶酪也许就在 附近，他们也许只是被人藏到墙的后面去了。”</p><p>　　第二天，哼哼和唧唧带了工具回到奶酪C站。哼哼拿着凿子，唧唧则用锤子敲打。他们费了九牛二虎之力，终于在墙上打出了一个洞，朝里面窥视，却依旧没有发现奶酪的踪迹。</p><p>　　尽管他们感到非常失望，但他们仍然相信问题会得到解决，以后，他们起得更早，工作时间更长、更努力。但是，一段时间以后，他们得到的只是一个个更大的空洞。</p><p>　　唧唧开始认识到行动和结果之间的区别。</p><p>　　“也许，”哼哼说：“我们只需要坐在这里，看看到底会发生什么事情。迟早他们会把奶酪再送回来的。”</p><p>　　唧唧希望他说的是真的。这样，他每天回家休息，然后勉强陪着哼哼去奶酪C站察看情况。但是，奶酪始终没有再出现。</p><p>　　由于焦虑和饥饿，这两个小矮人已经变得有些虚弱。唧唧已经开始厌倦等待—-完全被动地等着状况自己发生好转。他开始明白，他们在奶酪C站等待的时间越长，情况只会变得越糟糕。</p><p>　　唧唧明白，他们正失去自己的优势。</p><p>　　终于，有一天，唧唧开始自己嘲笑起自己来了：“唧唧呀唧唧，看看你自己吧！你居然等到每天重复同样的错误，还总是奇怪、怀疑为什么情况还没有得到改善，还有什么比你这种做法更可笑的呢？这如果不是荒谬，就是滑稽。”</p><p>　　唧唧并不想再到迷宫中去奔波。他知道他可能会迷路，而且他也不知道究竟应该到哪儿去寻找新的奶酪。但当他明白正是他的恐惧感使他如此裹足不前、坐以待毙的时候，他嘲笑自己的愚笨。</p><p>　　他问哼哼：“我们的运动衣和慢跑鞋放到哪里去了？”他花了很长时间才翻出了那些运动装备。当初，他们在奶酪C站找到奶酪以后，就把鞋啊什么的都扔到一边去了，因为他们满以为再也不会需要这些玩意儿了。</p><p>　　当哼哼看到他的朋友穿上运动服时，他说：“你不是真的要到迷宫中去吧？你为什么不留下来，和我一起在这里等，等着他们把奶酪送回来？” “因为如果这么做，我们将永远不会得到那些奶酪，”唧唧大声说：“不会有人把奶酪送回来了，现在已经到了去寻找新的奶酪的时候了，不要再想那些早已不存在的奶酪了！”</p><p>　　哼哼争辩说：“但是如果外面也没有奶酪怎么办？或者，即使有奶酪，但你找不到，又怎么办？”</p><p>　　“我不知道。”唧唧不耐烦地说。同样的问题，他已经问过自己多少遍了。他又感到了那种使他停滞不前的恐惧感。</p><p>　　但是马上，他又想到如果真的找到了新的奶酪呢？那种享受新奶酪的喜悦再度鼓起了他的勇气。 他最后问自己：“你希望到哪里去找奶酪—-这里还是迷宫中？”</p><p>　　于是他脑中出现了一幅图画，他看见自己面带微笑的在迷宫中探险。</p><p>　　这样的景象让他有些惊异，他发现自己终于克服了再次进入迷宫的恐惧。他看见自己在迷宫中迷了路，但仍然满怀信心地在那里寻找新的奶酪，一切美好的事物都随之而来。他又重新找回了自己的勇气。</p><p>　　于是，他尽量发挥自己的想象力，在脑海中为自己描绘了一幅他最信赖的、最具现实感的图画—-他在寻找和品尝新的奶酪。</p><p>　　他仿佛看见自己坐在一大堆奶酪中央，正在尽情品尝各种奶酪，像蜂窝状的瑞士奶酪、鲜黄的英国切达干酪、美国奶酪和意大利干酪，还有美妙又柔软的法国卡米伯特奶酪，等等。 唧唧简直想的入了神，知道他听见哼哼在一边嘟囔着什么，他才意识到自己仍然还站在奶酪C站。</p><p>　　于是唧唧转过身来对哼哼说：“哼哼，有时候，事情发生了改变，就再也变不会原来的样子了。我们现在遇到的情况就是这样。这就是生活！生活在变化，日子在往前走，我们也应随之改变，而不是在原地踟蹰不前。”</p><p>　　唧唧看着他那因饥饿和沮丧而显得有些憔悴的朋友，试图给他分析一些道理。但是，哼哼的畏惧早已变成了气恼，他什么也听不进去。</p><p>　　唧唧并不想冒犯他的朋友，但是他还是忍不住要嘲笑他们自己，因为现在看起来他们俩真是又狼狈又愚蠢。</p><p>　　当唧唧准备要出发的时候，他觉得自己整个人都变的充满了活力，他挺起了胸膛，他的精神开始振作起来：“让我们出发吧。”</p><p>　　唧唧大笑着宣称：“这是一个迷宫的时代！”</p><p>　　哼哼笑不出来，他几乎没有任何反应。</p><p>　　唧唧拾起一块坚硬的小石头，在墙上写下一句恳切的话，留给哼哼去思考。他没有忘记自己的习惯，在这句话的周围画上奶酪的图案。唧唧希望着幅画能给哼哼带来一丝希望，会对哼哼有所启发，并促使哼哼起身去追寻新的奶酪。但是哼哼根本不想朝墙上看一眼。</p><p>　　墙上的话是：</p><p>　　如果你不改变，你就会被淘汰。</p><p>　　在墙上留完言后，唧唧伸出脑袋小心翼翼地朝迷宫中望了望，回想着到达奶酪C站以前所走过的路线。</p><p>　　他曾经想过，也许迷宫中再也没有奶酪了，或者，他可能永远也找不到奶酪。这种悲观的情绪曾经那样深地植于他的心底，以至于差一点就毁了他。</p><p>　　想到这里，唧唧会心地微笑起来。他知道，哼哼现在一定还站在原地懊恼：“究竟是谁动了我的奶酪？”而唧唧此刻想到的确是：“我为什么没有早点行动起来，跟着奶酪移动呢？” 当唧唧终于走出奶酪C站踏入黑暗的迷宫时，他忍不住回头看了看这个曾经伴随他和哼哼很长一段时间的地方。那一瞬间他几乎无法控制自己，又想走回那个熟悉的地方，又想躲进那个虽然已没有奶酪但很安全的地方。</p><p>　　唧唧又有些担心起来，拿不准自己是否真的想要进入到迷宫中去。片刻以后，他又拿起石块在面前的墙上写下一句话，盯着它看了许久：</p><p><strong>如果你无所畏惧，你会怎样做呢？</strong></p><p>　　他对着这句话苦思冥想。</p><p>　　他知道，有时候，有所畏惧是有好处的。当你害怕不做某些事情会使事情变的越来越糟糕时，恐惧心反而会激起你去采取行动。但是，如果因为过分害怕而不敢采取任何行动时，恐惧心就会变成前进道路上最大的障碍。</p><p>　　他朝迷宫的右侧瞧了瞧，心中生出了恐惧，因为他从未到过那里面。</p><p>　　然后，他深吸了一口气，朝迷宫的右侧缓步跑去，跑向那片未知的领地。</p><p>　　在探路的时候，唧唧有些担心起来，一开始他还在奶酪C站犹豫了那么久，因为长时间没有吃到奶酪了，他有些虚弱。现在，在迷宫中穿行要比以前更加吃力，花的时间更长。他打定主意，一旦再有机会，他一定要尽早走出舒适的环境去适应事务的变化。他觉得立刻采取措施会使事情变的容易一些。 想到这里，唧唧无力地微笑了一下，感叹道：“迟做总比不做好。”</p><p>　　接下来地几天里，唧唧在周围偶尔能够找到一点奶酪，但都吃不了多久。他曾经希望能够找到足够多的奶酪，带回去给哼哼，鼓励他离开原地，走进迷宫。</p><p>　　但是，唧唧还是感到有些信心不足，他不得不承认，身在迷宫中，他感到十分困惑。里面很多地方跟以前完全不一样了。</p><p>　　他这样想着朝前走去，他觉得自己已经走了好远，却又好像就要迷失在迂回曲折的走廊中了。这就好像是在走两步退一步，对他来说真是一种挑战。不过他还是要承认，回到迷宫中寻找奶酪，其实并不像他想像的那样可怕。 随着时间的流逝，他开始有些怀疑，找到新奶酪的希望是否能变成现实。有种幻觉，有时他怀疑是否自己嘴里的奶酪太多而嚼不过来，这时，想到自己根本没有东西可嚼，他不禁哑然失笑。</p><p>　　每当他开始感到泄气的时候，他就提醒自己正在做什么。尽管现在很难受，但这样总比呆在没有奶酪的地方更实际。他在掌握控制权，而不是听天由命、束手无策。</p><p>　　他还提醒自己，如果嗅嗅和匆匆能不断前行，那么自己也能做到！</p><p>　　后来，唧唧回想起过去的事情，他终于明白奶酪C站的奶酪并不是像他曾经相信的那样一夜之间突然消失的。奶酪的数量是逐渐变少，直至完全消失的。而且，剩下的那一点也已经陈旧变质，美味丧失殆尽了。</p><p>　　那些陈旧的奶酪上面或许已经生出了霉菌，只是他没有注意到罢了。他还得承认，只要他愿意，应该能够注意的到，可惜他当初没有留意这些变化。</p><p>　　唧唧还认识到，如果他一直能够察觉到这些变化而且能够预见到这些变化，那么，这些变化就不会让他感到吃惊。也许，嗅嗅和匆匆一直就是这样做的。</p><p>　　他打定主意，从现在起，他要时刻保持警觉。他要期待着发生变化，而且还要去追寻变化，。他应该相信自己的直觉，能告意识到何时发生变化，并且能够做好准备去适应这些变化。</p><p>　　他停下来休息了一会，并在迷宫的墙上写道：</p><p>　　<strong>经常闻一闻你的奶酪</strong></p><p>　　你就会知道，</p><p>　　它什么时候开始变质。</p><p>　　一段日子以后，好像已经很久没有找到奶酪了。这天，唧唧遇到了一个很大的奶酪站，看起来里面似乎装满了奶酪。当他走进去以后，却发现里面空空如也，他失望至极。</p><p>　　“这种空空的感觉，对我来说太平常了。”他叹息道，他觉得自己就快要放弃了。</p><p>　　唧唧的体力正在慢慢地丧失。他知道自己迷路了，此刻，他有些担心自己能不能活下去。他想转身回到奶酪C站去。回去后，至少哼哼还在那里，唧唧就不会孤单一人了。这是，他又问了自己一个同样的问题：“如果我无所畏惧，我又会怎样做呢？” 唧唧觉得他正在克服和超越自己的恐惧，但他又越来越经常地感到害怕，害怕得甚至无法对自己承认。他常常难以确定自己到底害怕什么，但是在目前这样虚弱的状况下，他知道，他只是害怕一个人独自前行。唧唧其实并不清楚这一点，他只是在跟着这种感觉走，因为他一直在被这些恐惧得念头压迫着。</p><p>　　唧唧想知道哼哼是否已经离开了C站开始出发去寻找新的奶酪，或者是否仍然被自己得恐惧所吓倒，仍旧裹足不前。这时，唧唧想起他在迷宫中度过的时光，那些他曾经觉得是最美好的时光，其实正是他一个人穿行在迷宫中找寻奶酪的时候。</p><p>　　他又在墙上写下了一句话，以便提醒自己。同时，这句话也是一个标记，留给他的朋友哼哼，希望哼哼会跟上来。</p><p><strong>朝新的方向前进　你就会发现新的奶酪</strong></p><p>　　唧唧朝着黑暗深邃的通道中望去，又有一阵恐惧袭来。前面有些什么？是不是什么都没有？或者更糟，里面潜藏着危险？他开始想像各种可能降临到他头上的可怕的事情。他越想越怕，快把自己吓死了。</p><p>　　忽然，他又觉得自己真是可笑。他意识到，他的畏惧只会使事情变的更糟糕。于是，他采取了当他无所畏惧的时候他会采取的行动。他朝一个新的方向跑去。</p><p>　　当他跑向这条黑暗的走廊时，他笑了起来。唧唧还没认识到这一点，但他觉得他的灵魂得到了丰富。他正在放开自己，对前景充满了信心，尽管他并不能确切地知道前面究竟有些什么。</p><p>　　出乎意料，他开始对自己感到越来越满意。“为什么我感觉这么好？”他不明白：“我并没有找到奶酪，而且也不知道要到那里去。”</p><p>　　不久，他明白了他为什么会感觉这么好。他停下脚步，在墙上写道：</p><p>　　<strong>当你超越了自己的恐惧时，你就会感到轻松自在。</strong></p><p>　　他认识到，他原来是被自己的恐惧感给控制住了。如今朝一个新的方向迈进，使他获得了自由。</p><p>　　这时，从迷宫中吹来习习的凉风，使人感到神清气爽。他深吸了一口气，不觉振作起来。一旦克服了自己的恐惧感，他觉得一切比原来自己想像的要好得多。</p><p>　　唧唧已经很久没有这种感觉了。他几乎快要忘记了这种感觉是多么的惬意。</p><p>　　为了使事情更顺利地进行，他又开始在头脑中描绘一种景象。想像中，他在一种很棒的现实环境，坐在各种他喜欢的奶酪中间—-有切达奶酪还有布里奶酪！他看见自己在吃许多他喜欢吃的奶酪。这样的景象使他获得一种享受，他想像着这些奶酪的滋味该是多么美啊！</p><p>　　这种享受新奶酪的情景，他看得越清楚，就越相信这会变成现实。现在，他有一种感觉，他就要找到奶酪了，</p><p>　　他又在墙上写道：</p><p><strong>在我发现奶酪之前，想像我正在享受奶酪，这会帮我找到新的奶酪。</strong></p><p>　　唧唧一直在想的是他将会得到什么，而不是考虑他会失去什么。</p><p>　　他不明白，为什么自己过去总是觉得变化会使事情变得更糟，而现在他认识到，变化将会使事情变得更好。</p><p>　　“为什么以前我不明白这一点？”他反问自己。</p><p>　　于是，他以更大的勇气和力量快速灵敏地穿行在迷宫中。不久，他就发现了一个奶酪站。当他在迷宫的入口处发现一些新奶酪地碎屑时，他变得兴奋起来。</p><p>　　这是一些他从未见过的奶酪，但看起来挺不错，他尝了尝，真是美味啊！他吃掉了大部分能找到地小块奶酪，把剩下地放进口袋，以后也许可以和哼哼分享。他的体力也开始得到恢复。</p><p>　　他怀着兴奋地心情走进去。但是，让他感到惊愕的是，里面竟然是空的。有人已经来过这里，只留下了一些小块奶酪。</p><p>　　他认识到，如果能早一点行动，他就很可能早已在这里发现大量的新奶酪了。</p><p>　　唧唧决定会去，看看哼哼是否愿意和他一起行动，</p><p>　　在返回的路上，他停下来，在墙上写道：</p><p><strong>越早放弃旧的奶酪，你就会越早发现新的奶酪。</strong></p><p>　　不久，唧唧就回到了奶酪C站，找到了哼哼，他给哼哼一些新的小块奶酪，但被拒绝了。</p><p>　　哼哼很感激朋友的心意，但是他说：“我不喜欢新奶酪，这不是我习惯吃的那一种。我只要我自己的奶酪回来。除非可以得到我想要的东西，否则我是不会改变主意的。”</p><p>　　唧唧失望地摇摇头，不情愿地一个人踏上了自己地旅程。当走到他到达过的迷宫最深处时，他怀念起他的朋友来，但他明白，他喜欢的还是他的探险过程。虽然以前他想自己希望的是得到充足的新奶酪，但现在他清楚使自己快乐的并不仅仅是奶酪而已。 他高兴的是，他不再受自己的恐惧感的驱使。他喜欢自己正在做的事情，</p><p>　　明白了这一点，唧唧不再像在奶酪C站时，在没有奶酪的日子里感到那样的虚弱了。他知道，他不会再让恐惧感阻碍自己。他选择了一个新的方向，他的身心得到了滋养，体力得到加强。</p><p>　　现在，他觉得，找倒自己想要的东西只是一个时间问题。事实上，他感到自己已经找到了他一直在寻找的东西。</p><p>当他认识到这一点色时候，他不禁微笑起来，并在墙上写道：</p><p>　　<strong>在迷宫中搜寻比停留在没有奶酪的地方更安全。</strong></p><p>　　唧唧还认识到，就像他曾经体会过的那样，你所害怕的东西根本没有你想像的那样糟糕，在你心里形成的恐惧比你的实际处境更坏。他曾经是如此的害怕找不到新的奶酪，以致于他根本不想开始去寻找。然而一旦开始寻找的旅程，他就发现迷宫的走廊中有足够的奶酪使他继续找下去。现在，他期待着找到更多的奶酪。只要朝前看，他就会因为有所期待而兴奋起来。</p><p>　　他过去的思想被恐惧和忧虑蒙蔽了。过去考虑的总是没有奶酪，或者没有可以维持足够长时间的奶酪。以前总是觉得会把事情做错，而不是考虑把事情做好。</p><p>　　在他离开奶酪C站以后的日子里，一切都改变了。 过去他习惯于认为，奶酪决不会被拿走，改变总是不对的。</p><p>　　现在，他知道，变化会不断地发生，这是很自然的事情，不管你是否希望如此。只有当你不希望变化，也不想追寻变化的时候，变化才会让你感到吃惊。</p><p>当唧唧认识到自己的信念发生了变化时，他停下来，在墙上写道：</p><p><strong>陈旧的信念，不会帮助你找到新的奶酪。</strong></p><p>　　唧唧还没有找到奶酪，但在迷宫中穿行的时候，唧唧在想自己从中学到了什么。</p><p>　　他意识到，他的新的信念鼓舞着他采取新的行动。他的行为再不同于以往，再也不是总想回到同一个没有奶酪的地方。</p><p>　　他知道，当你改变了自己的信念，你也就改变了自己的行为。</p><p>　　你可以相信，变化对你有害，你可以拒绝它；或者，你会相信寻找新奶酪对你有好处，你会拥抱这种变化。</p><p>　　这些取决于你选择相信什么。</p><p>　　他在墙上写道：</p><p><strong>当你发现，你会找到新的奶酪，并且能够享用它时，你就会改变你的路线。</strong></p><p>　　唧唧知道，如果他能够早一些离开奶酪C站，早一点应对这些变化，他现在的状况就会更好一些。他的身体会更强壮，精神也会更坚强，会更好地去迎接挑战;寻找新奶酪的挑战。事实上，如果他不是浪费时间，否认已经发生了的变化，如果他能够期待改变，也许他已经找到奶酪了。 他再一次运用自己的想象力，看见自己正在发现和品尝新奶酪。他决定到更多的地方去，去迷宫中那些他还没有到过的地方。在这些地方，他偶尔找到一些小块的奶酪。唧唧又开始恢复了体力和信心。</p><p>　　当他回顾自己是怎么走过来的时候，他很高兴他在很多经过的地方的墙上都留下了字迹。他相信如果哼哼决定离开奶酪C站的话，这就是留给哼哼的路标，能帮助哼哼穿过迷宫。</p><p>　　唧唧只是希望自己在朝着正确的方向前进。他还想到了这种可能性—-哼哼将会读到墙上的字迹，并且循着它找到出路。</p><p>　　于是他又把这段时间以来他一直在思索着的心得写在了墙上：</p><p>　　<strong>尽早注意细小的变化，这将有助于你适应即将来临的更大的变化。</strong></p><p>　　此时此刻，唧唧早已把过去抛在脑后，正在适应现在。</p><p>　　他继续以更充沛的体力和更快的速度穿越迷宫。不久，期待已久的事情终于发生了。</p><p>　　当他感觉一直在迷宫中前行，而且好像永远都会在迷宫中前行的时候，他的旅程—-至少是现阶段的旅程;即将愉快地结束了。</p><p>　　唧唧正沿着一条走廊前进，这是一条他从未到过的走廊，拐过一个弯，在他的面前出现了奶酪N站，这里面堆满了新鲜的奶酪！</p><p>　　当他走进奶酪N站的时候，他被眼前的景象惊呆了。到处都是堆积如山的奶酪，他从未见过如此巨大的丰盛的贮藏。他并不完全认识这些奶酪，有些品种是全新的。 眼前的景象太壮观了，他犹豫了一会儿，不能肯定这是否是真的，或许这只是他的幻觉。直到他看见了他的老朋友嗅嗅和匆匆，他才相信这一切是真的。</p><p>　　嗅嗅冲唧唧点了点头，表示欢迎，匆匆则朝他挥了挥爪子。他们胖胖的小肚子表明，他们在这里已经有一段时间了。</p><p>　　唧唧很快向他们打了招呼，然后赶紧把他喜欢的各种奶酪都咬了一口。他脱掉鞋子，把两只鞋子系在一起，然后挂在脖子上，以便需要的时候能够迅速找到它们。嗅嗅和匆匆会心地笑了，并赞许地点了点头。而唧唧已经一头扎进了奶酪堆中。一顿饱餐之后，唧唧高兴地举起一块新鲜的奶酪欢呼：“呼啦。变化万岁！” 唧唧享受新的奶酪是同时，也在反思自己学到了什么。</p><p>　　他认识到，当他害怕变化的时候，他一直受困于对那已不复存在的就奶酪的幻想而无法自拔。</p><p>　　那又是什么使他发生了改变呢？难道是害怕饿死的恐惧？想到这里，唧唧笑了，他心里明白，这种恐惧当然起过很大的作用。</p><p>　　唧唧忽然发现，他已经学会自嘲了，而当人们学会自嘲，能够嘲笑自己的愚蠢和所作的错事时，他们就在开始改变了。他甚至觉得，改变自己的最快捷的方式，就是嘲笑自己的愚笨;这样，你就能对过往云烟轻松释然，迅速行动起来，直面变化。</p><p>　　唧唧相信他从他的老鼠朋友嗅嗅和匆匆那里，学到了一些有用的东西;不畏惧改变，勇往直前。老鼠朋友们简单地对待生活，他们不会反复分析，也不会把事情搞得很复杂。当形势发生改变，奶酪被移走了的时候，他们会迅速随之改变，循着奶酪的移动方向而移动。唧唧告诉自己，要牢记这些体会。</p><p>　　唧唧相信拥有了这些体会，凭借着自己聪慧的头脑，再遇到任何变化时他一定能够做得比老鼠朋友们更好。</p><p>　　他的头脑里出现了清晰的图画，他的生活将会变得更美好，而且他还会在迷宫中发现一些更好的东西。 唧唧不断地反思自己过去犯下的错误，他要汲取这些经验教训，去构划自己的未来。他知道，自己完全可以通过总结和学习，掌握如何应对变化：</p><p>　　首先要更清醒地认识到，有时需要简单地看待问题，以及灵敏快速地行动。</p><p>　　你不必把事情过分复杂化，或者一味地让那其次必须要善于发现一开始发生的那些细微的变化，以便你为即将来临的更大的变化做好准备。</p><p>　　他知道，他需要做出更快的调整。因为，如果不能及时调整自己，就可能永远找不到属于自己的奶酪。 还有一点必须承认，那就是阻止你发生改变的最大的制约因素就是你自己。只有自己发生了改变，事情才会开始好转。</p><p>　　最重要的事，新的奶酪始终总是存在于某个地方，不管你是否已经意识到了他的存在。只有当你克服了自己的恐惧念头，并且勇于走出久已习惯的生活，去享受冒险带来的喜悦的时候，你才会得到新奶酪给你的报偿和奖赏。</p><p>　　唧唧还认识到，有些畏惧是需要加以认真对待的，它会帮助你避开真正的危险。但绝大部分的恐惧都是不明智的，它们只会在你需要改变的时候，使你回避这种改变。 唧唧曾经那样地惧怕改变，他真的希望生活能够永远按照原有的样子继续，但现在他意识到，生活并不会遵从某个人的愿望发展。改变随时有可能降临，但积极地面对改变却会让你发现更好的奶酪，真的是塞翁失马，焉知非福。</p><p>　　唧唧已经看到了变化更好的一面。</p><p>　　当他回想起这些自己所学到的东西时，他不由得想起了他的朋友哼哼。他不知道哼哼是否读到了哪些他在奶酪C站和迷宫各个角落墙上的留言，不知道哼哼是否已经走出了迷宫。</p><p>　　哼哼是否已经决定放开已经失去的过去并且开始行动？他是否已经重新回到迷宫中。并且发现了能使他的生活变得更好的东西？</p><p>　　或者，他因为不肯改变，还在那里迟疑不前？</p><p>　　唧唧在考虑回到奶酪C站去，看看是否能找到哼哼—-但首先得肯定自己能找到回来的路。如果找到哼哼，他会把自己学到的东西告诉他，帮助他摆脱困境。但唧唧又想起他已经试图改变过他的失败的经历。</p><p>　　哼哼必须自己发现适合自己的道路，摆脱安逸，超越恐惧。没有人可以代替他做到这一点，或者告诉他应该怎样去做。他必须迈出第一步，否则他永远不会看到改变自己所带来的好处。</p><p>　　唧唧知道自己已经给哼哼留下了足够的标记，只要他能够迈出第一步，读到墙上的字迹，他就会找到奶酪。 于是唧唧打消了回奶酪C站的念头，他站起来走到奶酪N站最大的一面墙前，把他一路上得到的心得体会的要点写了下来。他拿起一块很大的奶酪，这是他见过的奶酪中最大的一块。唧唧品尝着新鲜的奶酪，望着自己写下的体会，脸上绽出了微笑：</p><p>　　&lt;变化总是在发生&gt;</p><p>　　他们总是不断地拿走你的奶酪。</p><p>　　&lt;预见变化&gt;</p><p>　　随时做好奶酪被拿走的准备。</p><p>　　&lt;追踪变化&gt;</p><p>　　经常闻一闻你的奶酪，以便知道它们什么时候开始变质。</p><p>　　&lt;尽快适应变化&gt;</p><p>　　越早放弃旧的奶酪，你就会越早享用到新的奶酪。</p><p>　　&lt;改 变&gt;</p><p>　　随着奶酪的变化而变化。</p><p>　　&lt;享受变化&gt;！</p><p>　　尝试冒险，去享受新奶酪的美味！</p><p>　　&lt;做好迅速变化的准备，不断地去享受变化&gt;</p><p>　　记住：他们仍会不断地拿走你的奶酪。　</p><p>　　唧唧在想，自从他在奶酪C站和哼哼分道扬镳以来已经有多久了。他知道自己前进了一大步，打他也很清楚，如果他过分沉溺于N区的安逸生活之中，他就会很快滑落到原来的困境。所以，他每天都仔细检查奶酪N站的情况。他在做一切力所能及的事情，以尽量避免被意料之外的变化打个措手不及。</p><p>　　当他还有大量的奶酪贮备时，他就开始经常到外面的迷宫中去，他所新的领地，以便自己与周围发生的变化随时保持联系。现在他非常明白，了解各种实际的选择，要比呆在舒适的环境里把自己孤立起来安全的多。 “窸窸窣窣”，他听到什么，唧唧竖起耳朵听了听，他觉得是从迷宫里传来的走动的声音。这声音渐渐大起来，他知道有人正向着这边跑来。</p><p>　　会是哼哼到了吗？他会循着那个弯转过来吗？</p><p>　　唧唧念了几句祈祷语，他真的希望;像他以前曾多次希望的那样—-也许，他的朋友终于能够……<br>  结局……或者是新的开始？</p><hr><h3 id="讨论"><a href="#讨论" class="headerlink" title="讨论:"></a>讨论:</h3><p>　　同一天傍晚，故事讲完以后的讨论</p><p>　　迈克尔讲完他的故事后，环顾四周，发现他的老同学都在微笑着倾听。</p><p>　　有几个人站起身来向他表示感谢，说他们从故事中得到了很多启发。</p><p>　　内森问大家：“一会儿我们聚在一起讨论一下这个故事，你们觉得怎样？”</p><p>　　大多数人都表示他们的确很想谈一谈自己的感受。于是，他们决定先去喝点东西，再吃晚餐，然后一起讨论这个故事。</p><p>　　当天晚上，他们聚集在饭店的房间，相互开着玩笑说，看见他们自己在迷宫中寻找各自的“奶酪”。</p><p>　　安杰拉要大家安静下来，并询问道：“你们觉得自己是这故事中的谁？嗅嗅和匆匆，还是哼哼或唧唧？”</p><p>　　卡洛斯第一个回答说：“呃，整个下午，我都在考虑这个问题。我清楚地记得，有一段时间，在我开始我的运动器材生产之前，我曾遇到过一次突如其来的改变。”</p><p>　　“我不是嗅嗅—-我没能及早嗅出潜在的危机并看出已经发生的变化。我也不像匆匆—–因为我没有立即投入行动。”</p><p>　　“我想我更像是哼哼，当时我只愿意呆在自己熟悉的领域。事实上，我根本不想去应对改变，我甚至不想看到变化。” 迈克尔和卡洛斯在学校时是好朋友，现在还是像以前一样亲密，他不解地问道：“兄弟，你所说的那个突然的改变究竟是怎么回事？”</p><p>　　卡洛斯说：“那是工作上的一个意想不到的变化。”</p><p>　　迈克尔笑起来：“你被开除了？”</p><p>　　“噢，还不如说，我只是从来不曾想过要去寻找新的奶酪。我曾经想到很多理由，总觉得变化不应该发生在我身上，老实说，那段时间，我感到非常沮丧。”</p><p>　　刚开始的时候，有几位同学一直没有参加讨论，现在听了迈克尔的话也都开始议论。首先是已经应征入伍的弗兰克。</p><p>　　“哼哼使我想起了我的一位朋友，”他说：“所有迹象显示他所在的部门将被裁撤，但他不肯面对这个现实。公司为所有人做了重新安排。我们都试图劝说他，只要愿意改变，公司里还有很多其他的机会，但他始终觉得自己没有必要改变。当他所在的部门最终关闭时，他是惟一惊讶得不知所措的人。现在，他正在做出艰难的调整，以适应他应为不该发生的变化。”</p><p>　　杰西卡说：“我也一向认为这种事情不会发生在我身上，但我的奶酪已经不止一次地被拿走了，尤其是在我的个人生活中。但最后我总能找到我的奶酪。”</p><p>　　除了内森，大家都笑了。</p><p>　　“也许，这就是关键之处，”内森说：“变化发生在我们每一个人身上。”</p><p>　　他补充道：“我真希望我的家人以前就听到过这个故事。不幸的是，我们第一个人都不愿意面对发生在我们家族企业中的变化。现在为时已晚—–我们不得不关闭我们的许多家店铺了。”</p><p>　　内森的话让很多人吃了一惊，因为大家一向都很羡慕内森幸运，认为他可以躺在自己的家族企业中，年复一年地依靠它。</p><p>　　“发生了什么事？”杰西卡急于问个究竟。</p><p>　　“当超级商场进入小镇时，我们的小型连锁店突然间显得过时了。他们有大量丰富且价格低廉的商品，我们完全与之竞争。”</p><p>　　“现在我终于明白了，这一切后果归咎于我的家人都不是嗅嗅和匆匆，我们就象哼哼。我们呆在原来的地方固步自封，拒绝改变；我们故意忽略外面的世界，企图对发生的一切视而不见。现在我们陷入了麻烦，这一要只是因为我们不愿意嘲讽自己，不愿意改变所做的。我们真应该从唧唧身上学到些什么。”</p><p>　　劳拉已经是一位很成功的商人，到现在为止，她很少说话，一直在聆听。“这个下午，我也一直在思考这个故事，”这时她说：“我不知自己要怎样做才能更像唧唧，才能够看到自己的错误，坦然面对自己，改变自己，并将一切做得更好。”</p><p>　　沉默了一会儿，她继续说：“我想知道，我们这时有多少人害怕改变？”见没有人回答。于是她又提议：“请举手示意。”</p><p>　　只有一个人举了手。“很好，看起来，我们之中总算还有一个诚实的人!”她说，并继续道：“也许你们更愿意回答下一个问题。有多少认为别人害怕改变？”这一次几乎每个人都举了手。见此情景，大伙都大笑起来。</p><p>　　“刚才的现象说明了什么？”</p><p>　　“我们都拒绝承认自己害怕改变。”内森回答。</p><p>　　“确实是这样，”迈克尔表示赞同，“有时候，连我们自己也没有意识到我们在害怕，或者说我们在努力想掩盖自己的恐惧。我知道我就是如此，当我第一次听到这个故事的时候，我就非常喜欢这句话，‘当你无所畏惧时，你会怎样’。” 杰西卡接口道：“我从这个故事中得到的启示是，变化无时无处不要发生，无论我们是害怕还是喜欢改变，但如果我们能尽快调整自己适应变化，我们应该可以做得更好。”</p><p>　　“我还记得几年前我们公司发生的事情。当时我们正在销售一套百科全书，全套书有二十多本。有个人想要说服我们，他告诉我们应该把整套百科全书做成一张计算机光盘，只卖现在价格的零头。这样做，既可以及时更新，又可以使生产费用大为减少，而且将有更多的人买得起并可以使用它。但是当时我们拒绝了这个建议。”</p><p>　　“你们为什么要拒绝呢？”内森问道。</p><p>　　“因为当时我们确信，我们企业的主力，是我们挨家挨户地推销的庞大销售队伍，我们的高价产品使我们的销售人员可以获得高额佣金从而更加卖力气地工作。长期以来，我们一直都这样做并且做得很成功，我们都认为这种方式还会继续有效。”</p><p>　　劳拉说：“也许这就是故事里所要表明的，哼哼和唧唧由于成功而形成的傲慢。他们从来没有，他们需要改变那些曾经是有效的东西。”</p><p>　　“这方法就是你们的奶酪!”内森说：“并且你们认为这块旧奶酪是你们惟一的奶酪。”</p><p>　　“的确如此，我们甚至想依靠这种方法直到永远。”</p><p>　　“当我回过头去想发生的事情时，我发现，奶酪不仅仅会被移走。奶酪也有自己的生命，终究有被吃完的一天。”</p><p>　　“结果怎么样呢？”劳拉问。</p><p>　　“我们没有变。一个竞争者做了改变，所以我们的生意一落千丈，一直到现在我们都很艰难。如今，在这个产业领域里技术上已经发生了很大的变化，但我们公司里却没有一个人想去应对这种变化。这看起来很不妙，我想我快要失业了。” </p><p>　　“这真是一个迷宫的时代!”卡洛斯忽然叫道。大家都笑了起来，杰西卡也笑了。</p><p>　　卡洛斯转向杰西卡说道：“你已经可以坦然地嘲笑你自己了，这很好啊。”</p><p>　　弗兰克附和说：“这也是我从故事中得到的体会，我们常常过于认真地看待自己。我注意到在故事里，当唧唧终于能够坦然嘲笑自己错误的过去时，他得到了应对变化的方法。关键就在于要敢于否定自己，勇敢地嘲讽自己做的傻事，难怪他的名字要叫作唧唧。”</p><p>　　大家都模仿这个词，发出哼哼唧唧的声音。</p><p>　　安杰拉问大家：“你们认为哼哼是否会改变，是否能够找到新的奶酪？”</p><p>　　依莱恩说：“我想他会的。” “我认为不会，”柯瑞说：“有的人绝对不肯改变，并为此付出了代价。在我行医的时候，我见过像哼哼这样的人。他们觉得他们天生具备拥有自己的奶酪的资格和权力，当奶酪被拿起以后，他们觉得自己是受害都并为此而指责别人，抱怨能够抱怨的一切。他们比那些最终能够放开自己去行动的人要病得厉害得多。”</p><p>　　这时，内森轻轻地、好像自言自语般地说道：“我觉得，真正的问题是，‘我们需要放弃什么，以及应该朝哪里行动？’”</p><p>　　好一会儿，大家都不说话。</p><p>　　“我必须承认，”内森又说：“当我看到其他地方的商业经营运作方式正在改变时，我完全有时间有能力改变自己去就应对这种变化，然而我们当时只是一厢情愿地认为这种变化不会影响到我们。所以我认为，率先变化比对变化做出反应和调整要强得多。也许，我们应该做的就是移走我们自己的奶酪。” </p><p>　　“你的意思是……”弗兰克问。</p><p>　　内森回答说：“我不禁在想，如果当初我们卖掉我们商店的不动产，建立一个大型的现代化商场与那些超级商场竞争，结果又会是怎样？”</p><p>　　劳拉说：“也许这就是唧唧写在墙上的意思‘尝试冒险，与奶酪一起变动’。”</p><p>　　弗兰克说：“我现在认识到，如果我很早就随着我的‘奶酪’移动，我会好得多。但我觉得有些东西是应该保持不变的，例如，我们的基本价值观。”</p><p>　　“噢，迈克尔，这真是一个有意义的小故事。”理查德说，他是班上的怀疑论者，“但是，我们究竟应该是怎样把它实际运用到我们的生活中去呢？”</p><p>　　大家都不知道，但理查德自己的生活正在经历某些变化。最近，他和妻子离婚了，因此既要做好工作又要照顾好十几岁的孩子。</p><p>　　迈克尔回答说：“你知道吗？以前我的工作就是处理每天正在发生的问题。现在我发现实际上我应该做的是，朝前看，把注意力放在我们公司发展的在大方向上，而不是不断地应付眼前的小事。”</p><p>　　“我整个人都投入到处理这些枝节问题中去了—-一天二十四小时，感受不到任何乐趣。我陷入老鼠赛跑的圈子，无法跑出来。”</p><p>　　“所以，你总是为琐事纠缠无暇喘息，而其实你更应该抽身出来，主动支配时间。”劳拉说。</p><p>　　“确实如此。”迈克尔说：“后来，当我听到‘谁动了我的奶酪’的故事后，我认识到我的工作应该是描绘一幅‘新奶酪’的图景—-公司全体员工都希望追寻的‘新奶酪’，然后将这新奶酪清晰、真实地呈现在所有员工的面前。这样，我们才会享受到变化和成功的喜悦，否认是在工作中还是在生活中。”</p><p>　　内森问道：“你在工作中是怎样去做的？”</p><p>　　“喔，我问我们公司里的人，他们是故事中的谁，发现我们公司中这四种角色都有。我看到了嗅嗅、匆匆、哼哼和唧唧，每一种角色都需要区别对待。”</p><p>　　“我们的嗅嗅能够敏锐地嗅出市场的变化，以便我们能够及时调整公司的战略。公司鼓励他们去识别哪些变化会影响顾客对新产品和服务的需求。嗅嗅们喜欢这项工作，他们告诉我，他们喜欢在这样的环境中工作，在这里他们能够识别变化并及时做出调整。”</p><p>　　“我们的匆匆喜欢做事，在公司的新战略，在公司的新战略中，他们被鼓励去采取行动。他们只需要稍加引导，以免跑错了方向。公司获得了新奶酪，这应归功于他们的行动。他们喜欢在这样的公司里工作，在这里能够体现行动的结果和价值。”</p><p>　　“那么，哼哼们就像是船锚想使我们停下来，”迈克尔说：“他们或者是太在意享受眼前的安逸，或者是过分害怕改变。不过当我向他们展示了具体的景象，并说明变化将会带来的好处时，有些哼哼最终改变了。”</p><p>　　“我们的哼哼们说，他们想要在一个安全的环境下工作，所以，变化应在他们所能接受的范围内并增加安全感。然而当我让他们认识到僵化不变的可怕时，其中有些人发生了改变，而且干得不错。这种景象使许多的哼哼变成了唧唧。”</p><p>　　“对那些没有改变的哼哼，你们怎么办呢？”弗兰克问道。</p><p>　　“我们不得不让他们走人。”迈克尔黯然答道：“我们希望留下所有的员工，但我们清楚，我们必须要迅速而充分地改变，否则我们全体都会陷入麻烦之中。”</p><p>　　他又说：“我们的唧唧们起初还有些犹豫，值得欣慰的是，他们思想开放，乐于去学习新的东西，及时调整并付诸实施，从而使我们获得成功。”</p><p>　　“他们甚至开始期待变化而且积极地寻求变化。他们了解大家究竟想要什么，和我们一起描绘出一幅实际可行的新奶酪的美景图，让所有的人充满期待并积极行动起来。”</p><p>　　“他们说他们希望在这样的组织中工作，能够给人自信和变化的工作。在我们追随新奶酪的过程中，他们还给我们带来了许多迎接挑战的乐趣。”</p><p>　　理查德揶揄道：“没想到你从一个小故事中得到了这么多东西？”</p><p>　　迈克尔笑了：“因为我并没有仅仅停留在听故事的层面上，而是从中找到了我想要的东西，并且采取了行动。”</p><p>　　安杰拉点头表示同意：“这做法真的很有趣。因为在我看来，这故事中最有影响力的部分是，当唧唧勇敢地嘲笑自己的畏惧，开始在头脑中描绘一幅自己在享受新奶酪的情景，然后充满信心和喜悦地走进迷宫，追寻新的奶酪，并最终获得了成功。我想这也是我常常想要做的事情。”</p><p>　　弗兰克笑了一下：“所以，甚至哼哼有时也能看到变化的好处。”</p><p>　　卡洛斯补充说：“甚至还有得到提拨的好处。”</p><p>　　理查德一直皱着眉头若有所思。这时他说：“我的上司一直在告诉我，公司需要有所改变。我想她实际上是想告诉我应该做出某些改变，但我实在不想听到这些。我觉得自己真的不知道，她想让我们去找的‘新奶酪’是什么，或者，我能从那新奶酪中得到些什么。”</p><p>　　说到这里，一丝微笑掠过他的脸庞：“听了这个故事我必须承认，我开始喜欢这个想法，看见新的奶酪并想像自己正在享用它。这种想法能使每件事都变得更有希望。当你想到变化能使事情变得更好时，你就会有很大的兴趣去促成变化的发生。”</p><p>　　“也许我应该把这些观念和方法运用到我的个人生活中去，”他说：“我的孩子们觉得他们的生活不应该改变。我看他们也有点像哼哼—-当事情发生改变时，他们会愤怒。因为他们不知道改变后会怎么样。这也许是我没有给他们描绘出一幅‘新奶酪’的美景的缘故。也许因为连我自己都害怕变化，连我自己都没有看到那‘新奶酪’的美景吧？”</p><p>　　听了这番话，所有人都想到了自己的生活，大家安静下来。</p><p>　　“呃，”杰西卡清了清嗓子，打破了宁静，“大家好像都在谈论自己的工作，但是我听到这个故事以后，却想到了我的个人生活。我觉得我目前的情况，我的家庭关系，就像一个‘旧奶酪’，上面长满了霉菌。”</p><p>　　柯瑞笑出声来，表示赞同：“我也是，也许我现在最该采取行动的就是让一段不愉快的关系尽快过去。”</p><p>　　安杰拉反驳道：“我不同意你的观点，也许这个‘旧奶酪’只是一种旧的方式。我们需要放弃的只是引起这种状态的旧的行为方式，而不是这个‘奶酪’。这样我们才会朝更好的思维和行为方式转变。”</p><p>　　“对呀!”柯瑞受到启发，“好观点。新奶酪说是用新的积极的行为方式与一个人建立新关系。”</p><p>　　理查德说：“我在想，也许这个故事还有更多有建设性的启发等待我们挖掘。我同意安杰拉的观点—-需要放弃的是旧的行为方式而不是关系本身。一成不变的行为方式还是会导致同样的结果。” “就工作而言，我应该成为帮助公司进行改变的人之一，而不是害怕公司的改变而辞去工作。如果早这么想、早这么做的话，我也许就会有一个更好的职位了。”</p><p>　　贝基生活在另一个城市，这次特意赶来参加同学聚会。这时她说：“当我在听这个故事，以及听到大家的讨论时，我真的禁不住要讥笑自己。许久以来，我一直像哼哼那样，害怕改变，凡事迟疑犹豫，拒绝改变，为此我不知道丢掉了多少美味的奶酪。我不知道其他人怎样，我恐怕已经在不得不中，把这种哼哼式的思想传给了我的孩子们。”</p><p>　　“当我反复思考这个问题和身边的一些人和事后，我在想或许变化真的能把你一个崭新的、更好的地方，尽管当时你担心事情的变化将并非如此。” “我记得有五段时间，在我儿子上中学二年级的时候。因为我先生工作的需要，我们必须从伊利诺搬到佛蒙特去，儿子为此很难过，因为他不得不离开他的朋友们了。他是学校里的游泳明星，但在佛蒙特的高中里却没有游泳队。因此，他对我们即将面临的变化感到很生气。”</p><p>　　“然而后来的情况是，他疯狂地迷上了佛蒙特的山区，开始学习滑雪，并参加了大学的滑雪队和登山队。现在，他有了更多的新伙伴，他愉快地生活在科罗拉多。” “如果当初面对改变时，我们全家能端上一杯热巧克力，一起享受这个故事的乐趣，或许我们家庭中的许多无谓的压力和紧张气氛早就烟消云散了。”</p><p>　　杰西卡赶忙说，“没错，我回去后，要把这个故事和全家分享。我还要问我的孩子们，我像故事中的谁—-嗅嗅、匆匆，还是哼哼和唧唧—-他们又觉得自己像谁。我们还要讨论，我们家的‘旧奶酪’是什么，‘新奶酪’又应该是什么。”</p><p>　　“这的确是个好主意!”理杰德大声赞同，把大家吓了一跳，连他自己都奇怪怎么会这么大声。</p><p>　　弗兰克也受到快乐情绪的感染，喜悦之情溢于言青：“我觉得自己越来越像唧唧，我已经做好准备随着奶酪的移动而移动，并且能够从中得到快乐!我也要把这个故事讲给我这中的朋友们，他们正担心离开部队后生活的变化。这一定会引起一场有趣的讨论。”</p><p>　　迈克尔接着说：“对，这也是我们当初改进我们企业的方法。我们搞过几场讨论，讨论我们从故事中学到什么，以及如何把它们运用到我们的实际工作中去。”</p><p>　　“这很重要。因为我们有了轻松的、共同的语言，用来谈论怎样应对变化，包括公司的和个人生活的。这方法非常有效，它已经深深地渗入到我们公司的各个方面。”</p><p>　　内森问道：“‘深深地’是什么意思？” “喔，是这样的，我们发现，越是组织的内层，就越缺乏活力。可以理解，他们比外层人员更加害怕改变，害怕上面强加给他们的改变会发生在他们身上。所以，他们拒绝改变。”</p><p>　　“简言之，强加的改变是最易遭到反抗及阻力的改变。”</p><p>　　“当‘奶酪的故事’以书面的形式在我们机构中分发出去以后，它改变了大家看待变化的态度。对于自己过去的畏惧，每个人都笑起来，至少是微笑了。每一个人都开始主动地考虑‘改变’这个题目。”</p><p>　　“但我要是能够早点听到‘奶酪’的故事并把它用于公司讨论就好了!”迈克尔加了一句。</p><p>　　“为什么？”卡洛斯不理解地问。</p><p>　　“因为当我们开始向变化靠拢的时候，我们的企业已经一团糟了。生意一落千丈，我们不得不解雇一些 员工，正如我前面提到的，甚至包括一些好朋友。这对我们大家来说都是一件痛苦的事情。惟一值得欣慰的是，所有留下来的和大多数离去的人都说，奶酪的故事使他们改变了看问题的方式，使他们能够更好地对付各种局面。”</p><p>　　“那些离开公司，出去找新工作的人说，开始时确实很艰难，但是，每每回想起这个故事，就会得到极大的帮助。”</p><p>　　安杰拉问道：“对他们最大的帮助是什么？”</p><p>　　迈克尔回答：“他们告诉我，超越自己的恐惧的最大好处是，他们认识到外面到处有新奶酪等着被发 现，只要他们愿意去寻找。”</p><p>　　“他们说，头脑中存有一幅新奶酪的景像—-看见自己在新的工作中干得很好—-会使他们的感觉好一些。尤其是使他们在面试的时候表现得更为出色。有些人还因此得到了比原来更好的工作。”</p><p>　　劳拉问：“那些留在公司的人又怎么样了呢？”</p><p>　　“噢，”迈克尔说：“人们不再抱怨市场环境正在发生的种种变化。他们说‘既然我们的旧奶酪已经不见了，那么让我们去找新的奶酪吧。’这省去了公司许多的协调时间，也减少了公司内部的紧张感和压力。”</p><p>　　“不久前还完全拒绝变化的人，如今也透过这个小故事看到了变化的好处。他们越来越喜欢变化，并且积极创造有利于公司发展的变化。”</p><p>　　柯瑞说：“是什么使得他们改变了呢？”</p><p>　　“我认为这和公司里面存在的同事之间的相互影响力有关系，”迈克尔答道：“如果这种影响力改变了，人们就会跟着发生改变。”</p><p>　　“大家可以回想一下，在你呆过的机构里面，当上级宣布一项改变时，大多数人会有什么反应？大多数人会说这改变是一个好主意还是一个坏主意？”</p><p>　　“一个坏主意。”弗兰克答道。</p><p>　　“没错。”迈克尔表示同意，又接着问道：“为什么会这样呢？”</p><p>　　卡洛斯说：“我想因为大多数人都喜欢稳定和有安全感，他们觉得改变会带给自己麻烦甚至有可能对自己不得。当有一个人说这种改变是一个坏主意时，其他人通常会随声附和。”</p><p>　　“的确如此，但这些随声附和的人在心里也许并不真的这样认为。”迈克尔说：“只是他们为了看起来和最先提议反对的那个人一样聪明以及显得合群，就会随声附和。这就是我所说的同事之间的相互影响力。这种影响力通常会阻碍机构中发生的变化。”</p><p>　　贝基问道：“那么当人们听到奶酪的故事以后，情况又怎么样了？”</p><p>　　迈克尔耸了耸肩膀，轻松地说：“情况是同事之间的相互影响力改变了，因为大家都不希望自己被别人叫作哼哼!”</p><p>　　大家听了都哈哈大笑了起来。</p><p>　　“他们都想提前嗅出变化的味道，并且赶快投入行动，而不再是落在后头哼哼不停。”</p><p>　　内森说：“这是一个好点子。我想我们家的人也都不愿做哼哼，他们很可能也会因为这个故事而改变。上一次同学聚会时，你为什么没有告诉我们这个故事？要不然，它早起作用了。”</p><p>　　“它确实有用。”迈克尔说。</p><p>　　“而且非常有用!尤其是当你的机构中的每个人都知道它时—-不管是大公司，还是小企业，或者是你的家庭—-因为，只有当其中的多数人的心态发生改变以后，一个组织才会发生变化。”</p><p>　　最后，迈克尔又给大家介绍了一个经验：“当这个故事对我的公司起作用以后，我们便把这故事告诉给那些我们希望能和他们在生意上有所合作的人，因为我们知道任何一个公司都正面临变化和选择。我们提议说，也许我们就是他们正在找寻的‘新奶酪’，也就是说，我们可能就是能让他们的生意更成功的合作伙伴。这方法的确为我们带来了许多新的机会和生意。”</p><p>　　这番话使杰西卡受到启发，她想起明天上午要谈的几笔业务。她赶紧看了看时间，说：“喔，时间到了，该是我离开这个奶酪站，去寻找新的奶酪的时候了。”</p><p>　　大家都会心地笑了起来，然后站起身来互道晚安。尽管许多人觉得兴犹未尽，还想继续聊这个话题，但时间的确已经不早了。分手的时候，他们再一次感谢迈克尔。</p><p>　　迈克尔说：“我非常高兴你们觉得这个故事对你们有所帮助，我也衷心希望你们有机会尽快与别人分享这个故事。”</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;《谁动了我的奶酪》（Who　Moved　My　Cheese?），生动的阐述了“变是唯一的不变”这一生活真谛，据说已经成为全世界最畅销的书。或许每一个人看完的感受都不一样，但千万不要说这个道理我懂，如果那样就说明你依然惧怕改变自己。&lt;/p&gt;</summary>
    
    
    
    <category term="读书笔记" scheme="https://hyacinth.fit/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="文学" scheme="https://hyacinth.fit/tags/%E6%96%87%E5%AD%A6/"/>
    
  </entry>
  
</feed>
